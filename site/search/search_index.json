{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overthewire Solutions","text":""},{"location":"#the-rules","title":"The Rules","text":"<p>First thing first, ensure to always comply with the rules of the wargames</p>"},{"location":"#why-does-this-documentation-exists","title":"Why does this documentation exists?","text":"<p>While solving the first challenge, bandit, I had a hard time finding two things:</p> <ol> <li>Quality solutions</li> <li>Hints to solve the challenge instead of the solution given right away</li> </ol> <p>This is because of this lack that I decided to record what I learned in this Documentation</p>"},{"location":"#what-should-you-expect-to-find-in-this-documentation","title":"What should you expect to find in this documentation?","text":"<p>The name is pretty self-explanatory, you'll find the solutions to the Overthewire Wargames. However, even though you'll find the solutions, the documentation will also include some commonly  encountered difficulties and some hints before unveilling the solution so that any person that comes  here looking for advice without being spoiled the solution can do so without any fear.</p>"},{"location":"#but-shelltief-what-are-the-overthewire-wargames","title":"But Shelltief, what are the overthewire wargames?","text":"<p>Let's ask ChatGPT to describe the wargames:</p> <p>OverTheWire is a platform offering a variety of cybersecurity wargames designed to teach and improve hacking and security skills through hands-on practice. These challenges cover a broad range of topics from basic command-line skills to advanced exploitation techniques. Each wargame is divided into levels, and each level presents a unique challenge that needs to be solved to progress to the next. The platform is ideal for learners at various stages, providing a structured learning path in a safe and legal environment. General Overview of OverTheWire Challenges:</p>"},{"location":"#purpose","title":"Purpose","text":"<ul> <li>To teach and enhance cybersecurity skills.</li> <li>To provide practical experience with various hacking techniques.</li> <li>To offer a structured and progressively challenging learning environment.</li> </ul>"},{"location":"#structure","title":"Structure","text":"<ul> <li>Challenges are divided into different wargames, each focusing on specific aspects of cybersecurity.</li> <li>Each wargame consists of multiple levels, with each level requiring the player to solve a particular problem or exploit a vulnerability to retrieve a password or key to progress to the next level.</li> </ul>"},{"location":"#learning-outcomes","title":"Learning Outcomes","text":"<ul> <li>Mastery of basic to advanced Linux command-line skills.</li> <li>Understanding of binary exploitation and reverse engineering.</li> <li>Familiarity with web application security vulnerabilities.</li> <li>Knowledge of cryptographic principles and methods.</li> <li>Experience with real-world cybersecurity scenarios and problem-solving techniques.</li> </ul>"},{"location":"#popular-wargames-on-overthewire","title":"Popular Wargames on OverTheWire","text":"<ul> <li>Bandit: Focuses on basic Linux command-line skills, file manipulation, and introductory scripting.<ul> <li>Walkthrough</li> </ul> </li> <li>Leviathan: Introduces basic binary exploitation and reverse engineering concepts.</li> <li>Narnia: Delves deeper into binary exploitation, including stack overflows and format string vulnerabilities.</li> <li>Natas: Focuses on web application security, covering common web vulnerabilities such as SQL injection and XSS.</li> <li>Krypton: Introduces cryptographic principles and challenges involving various types of ciphers.</li> <li>Vortex: Offers advanced binary exploitation and reverse engineering challenges for more experienced players.</li> </ul> <p>Each wargame is designed to be educational, providing a step-by-step progression from simpler to more complex challenges, allowing players to build their skills incrementally. The platform is widely used by cybersecurity enthusiasts, students, and professionals to practice and refine their hacking abilities in a controlled and educational setting.</p>"},{"location":"#what-now","title":"What now ?","text":"<p>Now, you can let me walk you through the solutions of the first challenge, bandit. The solutions are available here</p>"},{"location":"#must-read","title":"Must Read","text":"<p>Here are a selection of ressources gathered on the internet on how to ask for help. This might be very useful, be it during the challenges or during any other stage of your learning journey so ensure you read it thoroughly, even if you didn't learn a thing it will at the very least remind you that RTFM is not an indicator of rudeness, but an invitation to autonomy.</p> <ul> <li>How To Ask Questions The Smart Way A reference informative document about how to ask questions</li> <li>How do I ask a good question? A Stackoverflow blogpost on how to ask a question on the forum</li> <li>How to debug small programs A blogpost about autonomy in debugging before asking questions</li> </ul>"},{"location":"#useful-ressources","title":"Useful Ressources","text":"<ul> <li>Challenge Status A link that indicates all the overthewire challenges that are down, if it's green then you need to try harder</li> <li>Introduction to user commands</li> </ul>"},{"location":"#reminder-cleanup-after-yourself","title":"Reminder - Cleanup after yourself","text":"<p>For the challenges where you need to work in a temporary directory, you can run the following command :  <pre><code>cd $HOME &amp;&amp; rm -rf $OLDPWD\n</code></pre> to remove the contents of the temporary directory you were in.</p>"},{"location":"#on-the-importance-of-sourcing","title":"On the importance of sourcing","text":"<p>I thought I'd end this README by sharing with you something I learned the hard way : More often than not, it is a pain in the a** to find links to official documentation.  People seems to find more relevant to link to online tutorials (when then even bother to do so). This statement is not to be taken as a general as there are,  thankfully, a lot of people that link to official doc.</p>"},{"location":"#why-do-i-even-bother-talking-about-it","title":"Why do I even bother talking about it ?","text":"<p>By including links to official documentation, we ensure trustworthiness, accuracy and we give the opportunity to people to learn more concepts that revolve around the documentation (and that's also a kind way to teach them how to RTFM).</p> <p>So I hope you'll find all the work here useful, it was fun yet painful doing all the research work but it helped me understand a lot of things about programming and I hope it will help you too.</p> <p>Without any mode delay, let's dive right into the first challenge</p>"},{"location":"license/","title":"License","text":"<p>Attribution-NonCommercial-ShareAlike 4.0 International</p> <p>=======================================================================</p> <p>Creative Commons Corporation (\"Creative Commons\") is not a law firm and does not provide legal services or legal advice. Distribution of Creative Commons public licenses does not create a lawyer-client or other relationship. Creative Commons makes its licenses and related information available on an \"as-is\" basis. Creative Commons gives no warranties regarding its licenses, any material licensed under their terms and conditions, or any related information. Creative Commons disclaims all liability for damages resulting from their use to the fullest extent possible.</p> <p>Using Creative Commons Public Licenses</p> <p>Creative Commons public licenses provide a standard set of terms and conditions that creators and other rights holders may use to share original works of authorship and other material subject to copyright and certain other rights specified in the public license below. The following considerations are for informational purposes only, are not exhaustive, and do not form part of our licenses.</p> <pre><code> Considerations for licensors: Our public licenses are\n intended for use by those authorized to give the public\n permission to use material in ways otherwise restricted by\n copyright and certain other rights. Our licenses are\n irrevocable. Licensors should read and understand the terms\n and conditions of the license they choose before applying it.\n Licensors should also secure all rights necessary before\n applying our licenses so that the public can reuse the\n material as expected. Licensors should clearly mark any\n material not subject to the license. This includes other CC-\n licensed material, or material used under an exception or\n limitation to copyright. More considerations for licensors:\nwiki.creativecommons.org/Considerations_for_licensors\n\n Considerations for the public: By using one of our public\n licenses, a licensor grants the public permission to use the\n licensed material under specified terms and conditions. If\n the licensor's permission is not necessary for any reason--for\n example, because of any applicable exception or limitation to\n copyright--then that use is not regulated by the license. Our\n licenses grant only permissions under copyright and certain\n other rights that a licensor has authority to grant. Use of\n the licensed material may still be restricted for other\n reasons, including because others have copyright or other\n rights in the material. A licensor may make special requests,\n such as asking that all changes be marked or described.\n Although not required by our licenses, you are encouraged to\n respect those requests where reasonable. More considerations\n for the public:\nwiki.creativecommons.org/Considerations_for_licensees\n</code></pre> <p>=======================================================================</p> <p>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Public License</p> <p>By exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Public License (\"Public License\"). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.</p> <p>Section 1 -- Definitions.</p> <p>a. Adapted Material means material subject to Copyright and Similar      Rights that is derived from or based upon the Licensed Material      and in which the Licensed Material is translated, altered,      arranged, transformed, or otherwise modified in a manner requiring      permission under the Copyright and Similar Rights held by the      Licensor. For purposes of this Public License, where the Licensed      Material is a musical work, performance, or sound recording,      Adapted Material is always produced where the Licensed Material is      synched in timed relation with a moving image.</p> <p>b. Adapter's License means the license You apply to Your Copyright      and Similar Rights in Your contributions to Adapted Material in      accordance with the terms and conditions of this Public License.</p> <p>c. BY-NC-SA Compatible License means a license listed at      creativecommons.org/compatiblelicenses, approved by Creative      Commons as essentially the equivalent of this Public License.</p> <p>d. Copyright and Similar Rights means copyright and/or similar rights      closely related to copyright including, without limitation,      performance, broadcast, sound recording, and Sui Generis Database      Rights, without regard to how the rights are labeled or      categorized. For purposes of this Public License, the rights      specified in Section 2(b)(1)-(2) are not Copyright and Similar      Rights.</p> <p>e. Effective Technological Measures means those measures that, in the      absence of proper authority, may not be circumvented under laws      fulfilling obligations under Article 11 of the WIPO Copyright      Treaty adopted on December 20, 1996, and/or similar international      agreements.</p> <p>f. Exceptions and Limitations means fair use, fair dealing, and/or      any other exception or limitation to Copyright and Similar Rights      that applies to Your use of the Licensed Material.</p> <p>g. License Elements means the license attributes listed in the name      of a Creative Commons Public License. The License Elements of this      Public License are Attribution, NonCommercial, and ShareAlike.</p> <p>h. Licensed Material means the artistic or literary work, database,      or other material to which the Licensor applied this Public      License.</p> <p>i. Licensed Rights means the rights granted to You subject to the      terms and conditions of this Public License, which are limited to      all Copyright and Similar Rights that apply to Your use of the      Licensed Material and that the Licensor has authority to license.</p> <p>j. Licensor means the individual(s) or entity(ies) granting rights      under this Public License.</p> <p>k. NonCommercial means not primarily intended for or directed towards      commercial advantage or monetary compensation. For purposes of      this Public License, the exchange of the Licensed Material for      other material subject to Copyright and Similar Rights by digital      file-sharing or similar means is NonCommercial provided there is      no payment of monetary compensation in connection with the      exchange.</p> <p>l. Share means to provide material to the public by any means or      process that requires permission under the Licensed Rights, such      as reproduction, public display, public performance, distribution,      dissemination, communication, or importation, and to make material      available to the public including in ways that members of the      public may access the material from a place and at a time      individually chosen by them.</p> <p>m. Sui Generis Database Rights means rights other than copyright      resulting from Directive 96/9/EC of the European Parliament and of      the Council of 11 March 1996 on the legal protection of databases,      as amended and/or succeeded, as well as other essentially      equivalent rights anywhere in the world.</p> <p>n. You means the individual or entity exercising the Licensed Rights      under this Public License. Your has a corresponding meaning.</p> <p>Section 2 -- Scope.</p> <p>a. License grant.</p> <pre><code>   1. Subject to the terms and conditions of this Public License,\n      the Licensor hereby grants You a worldwide, royalty-free,\n      non-sublicensable, non-exclusive, irrevocable license to\n      exercise the Licensed Rights in the Licensed Material to:\n\n        a. reproduce and Share the Licensed Material, in whole or\n           in part, for NonCommercial purposes only; and\n\n        b. produce, reproduce, and Share Adapted Material for\n           NonCommercial purposes only.\n\n   2. Exceptions and Limitations. For the avoidance of doubt, where\n      Exceptions and Limitations apply to Your use, this Public\n      License does not apply, and You do not need to comply with\n      its terms and conditions.\n\n   3. Term. The term of this Public License is specified in Section\n      6(a).\n\n   4. Media and formats; technical modifications allowed. The\n      Licensor authorizes You to exercise the Licensed Rights in\n      all media and formats whether now known or hereafter created,\n      and to make technical modifications necessary to do so. The\n      Licensor waives and/or agrees not to assert any right or\n      authority to forbid You from making technical modifications\n      necessary to exercise the Licensed Rights, including\n      technical modifications necessary to circumvent Effective\n      Technological Measures. For purposes of this Public License,\n      simply making modifications authorized by this Section 2(a)\n      (4) never produces Adapted Material.\n\n   5. Downstream recipients.\n\n        a. Offer from the Licensor -- Licensed Material. Every\n           recipient of the Licensed Material automatically\n           receives an offer from the Licensor to exercise the\n           Licensed Rights under the terms and conditions of this\n           Public License.\n\n        b. Additional offer from the Licensor -- Adapted Material.\n           Every recipient of Adapted Material from You\n           automatically receives an offer from the Licensor to\n           exercise the Licensed Rights in the Adapted Material\n           under the conditions of the Adapter's License You apply.\n\n        c. No downstream restrictions. You may not offer or impose\n           any additional or different terms or conditions on, or\n           apply any Effective Technological Measures to, the\n           Licensed Material if doing so restricts exercise of the\n           Licensed Rights by any recipient of the Licensed\n           Material.\n\n   6. No endorsement. Nothing in this Public License constitutes or\n      may be construed as permission to assert or imply that You\n      are, or that Your use of the Licensed Material is, connected\n      with, or sponsored, endorsed, or granted official status by,\n      the Licensor or others designated to receive attribution as\n      provided in Section 3(a)(1)(A)(i).\n</code></pre> <p>b. Other rights.</p> <pre><code>   1. Moral rights, such as the right of integrity, are not\n      licensed under this Public License, nor are publicity,\n      privacy, and/or other similar personality rights; however, to\n      the extent possible, the Licensor waives and/or agrees not to\n      assert any such rights held by the Licensor to the limited\n      extent necessary to allow You to exercise the Licensed\n      Rights, but not otherwise.\n\n   2. Patent and trademark rights are not licensed under this\n      Public License.\n\n   3. To the extent possible, the Licensor waives any right to\n      collect royalties from You for the exercise of the Licensed\n      Rights, whether directly or through a collecting society\n      under any voluntary or waivable statutory or compulsory\n      licensing scheme. In all other cases the Licensor expressly\n      reserves any right to collect such royalties, including when\n      the Licensed Material is used other than for NonCommercial\n      purposes.\n</code></pre> <p>Section 3 -- License Conditions.</p> <p>Your exercise of the Licensed Rights is expressly made subject to the following conditions.</p> <p>a. Attribution.</p> <pre><code>   1. If You Share the Licensed Material (including in modified\n      form), You must:\n\n        a. retain the following if it is supplied by the Licensor\n           with the Licensed Material:\n\n             i. identification of the creator(s) of the Licensed\n                Material and any others designated to receive\n                attribution, in any reasonable manner requested by\n                the Licensor (including by pseudonym if\n                designated);\n\n            ii. a copyright notice;\n\n           iii. a notice that refers to this Public License;\n\n            iv. a notice that refers to the disclaimer of\n                warranties;\n\n             v. a URI or hyperlink to the Licensed Material to the\n                extent reasonably practicable;\n\n        b. indicate if You modified the Licensed Material and\n           retain an indication of any previous modifications; and\n\n        c. indicate the Licensed Material is licensed under this\n           Public License, and include the text of, or the URI or\n           hyperlink to, this Public License.\n\n   2. You may satisfy the conditions in Section 3(a)(1) in any\n      reasonable manner based on the medium, means, and context in\n      which You Share the Licensed Material. For example, it may be\n      reasonable to satisfy the conditions by providing a URI or\n      hyperlink to a resource that includes the required\n      information.\n   3. If requested by the Licensor, You must remove any of the\n      information required by Section 3(a)(1)(A) to the extent\n      reasonably practicable.\n</code></pre> <p>b. ShareAlike.</p> <pre><code> In addition to the conditions in Section 3(a), if You Share\n Adapted Material You produce, the following conditions also apply.\n\n   1. The Adapter's License You apply must be a Creative Commons\n      license with the same License Elements, this version or\n      later, or a BY-NC-SA Compatible License.\n\n   2. You must include the text of, or the URI or hyperlink to, the\n      Adapter's License You apply. You may satisfy this condition\n      in any reasonable manner based on the medium, means, and\n      context in which You Share Adapted Material.\n\n   3. You may not offer or impose any additional or different terms\n      or conditions on, or apply any Effective Technological\n      Measures to, Adapted Material that restrict exercise of the\n      rights granted under the Adapter's License You apply.\n</code></pre> <p>Section 4 -- Sui Generis Database Rights.</p> <p>Where the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:</p> <p>a. for the avoidance of doubt, Section 2(a)(1) grants You the right      to extract, reuse, reproduce, and Share all or a substantial      portion of the contents of the database for NonCommercial purposes      only;</p> <p>b. if You include all or a substantial portion of the database      contents in a database in which You have Sui Generis Database      Rights, then the database in which You have Sui Generis Database      Rights (but not its individual contents) is Adapted Material,      including for purposes of Section 3(b); and</p> <p>c. You must comply with the conditions in Section 3(a) if You Share      all or a substantial portion of the contents of the database.</p> <p>For the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.</p> <p>Section 5 -- Disclaimer of Warranties and Limitation of Liability.</p> <p>a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE      EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS      AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF      ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS,      IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION,      WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR      PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS,      ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT      KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT      ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.</p> <p>b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE      TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,      NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT,      INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES,      COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR      USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN      ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR      DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR      IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.</p> <p>c. The disclaimer of warranties and limitation of liability provided      above shall be interpreted in a manner that, to the extent      possible, most closely approximates an absolute disclaimer and      waiver of all liability.</p> <p>Section 6 -- Term and Termination.</p> <p>a. This Public License applies for the term of the Copyright and      Similar Rights licensed here. However, if You fail to comply with      this Public License, then Your rights under this Public License      terminate automatically.</p> <p>b. Where Your right to use the Licensed Material has terminated under      Section 6(a), it reinstates:</p> <pre><code>   1. automatically as of the date the violation is cured, provided\n      it is cured within 30 days of Your discovery of the\n      violation; or\n\n   2. upon express reinstatement by the Licensor.\n\n For the avoidance of doubt, this Section 6(b) does not affect any\n right the Licensor may have to seek remedies for Your violations\n of this Public License.\n</code></pre> <p>c. For the avoidance of doubt, the Licensor may also offer the      Licensed Material under separate terms or conditions or stop      distributing the Licensed Material at any time; however, doing so      will not terminate this Public License.</p> <p>d. Sections 1, 5, 6, 7, and 8 survive termination of this Public      License.</p> <p>Section 7 -- Other Terms and Conditions.</p> <p>a. The Licensor shall not be bound by any additional or different      terms or conditions communicated by You unless expressly agreed.</p> <p>b. Any arrangements, understandings, or agreements regarding the      Licensed Material not stated herein are separate from and      independent of the terms and conditions of this Public License.</p> <p>Section 8 -- Interpretation.</p> <p>a. For the avoidance of doubt, this Public License does not, and      shall not be interpreted to, reduce, limit, restrict, or impose      conditions on any use of the Licensed Material that could lawfully      be made without permission under this Public License.</p> <p>b. To the extent possible, if any provision of this Public License is      deemed unenforceable, it shall be automatically reformed to the      minimum extent necessary to make it enforceable. If the provision      cannot be reformed, it shall be severed from this Public License      without affecting the enforceability of the remaining terms and      conditions.</p> <p>c. No term or condition of this Public License will be waived and no      failure to comply consented to unless expressly agreed to by the      Licensor.</p> <p>d. Nothing in this Public License constitutes or may be interpreted      as a limitation upon, or waiver of, any privileges and immunities      that apply to the Licensor or You, including from the legal      processes of any jurisdiction or authority.</p> <p>=======================================================================</p> <p>Creative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the \u201cLicensor.\u201d The text of the Creative Commons public licenses is dedicated to the public domain under the CC0 Public Domain Dedication. Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at creativecommons.org/policies, Creative Commons does not authorize the use of the trademark \"Creative Commons\" or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses.</p> <p>Creative Commons may be contacted at creativecommons.org.</p>"},{"location":"bandit/docs/","title":"Bandit Challenge","text":""},{"location":"bandit/docs/#overview-of-the-bandit-challenge","title":"Overview of the Bandit Challenge","text":""},{"location":"bandit/docs/#bandit-challenge-description","title":"Bandit Challenge Description","text":"<p>Bandit is the entry-level wargame on OverTheWire designed to teach beginners the basics of using the Linux command line. It focuses on fundamental skills such as file navigation, file manipulation, and simple scripting. The game is structured into multiple levels, each presenting a unique challenge that requires players to use various Linux commands and techniques to retrieve a password needed to access the next level. Bandit is an excellent starting point for anyone new to the command line or looking to solidify their basic skills.</p>"},{"location":"bandit/docs/#general-structure","title":"General Structure","text":"<ol> <li>Levels: The Bandit wargame consists of over 30 levels. Each level is accessible via SSH, and players must solve the current level's challenge to obtain the password for the next level.</li> <li>Challenges: Each level's challenge is designed to teach a specific command or concept related to Linux. Challenges range from locating hidden files to manipulating text, understanding file permissions, and using basic scripting.</li> <li>Tools and Commands: Players will become familiar with a variety of essential Linux commands and tools, including but not limited to:</li> <li><code>ls</code>, <code>cd</code>, <code>cat</code>, <code>file</code>, <code>find</code>, <code>grep</code>, <code>sort</code>, <code>uniq</code>, <code>strings</code>, <code>chmod</code>, <code>ssh</code>, <code>scp</code>, and simple bash scripting.</li> </ol>"},{"location":"bandit/docs/#learning-outcomes","title":"Learning Outcomes","text":"<ul> <li>Command Line Proficiency: Gain confidence and proficiency with the Linux command line, essential for any cybersecurity or IT professional.</li> <li>Problem-Solving Skills: Develop logical thinking and problem-solving skills by tackling progressively more difficult challenges.</li> <li>Practical Knowledge: Learn how to navigate the file system, manipulate files, and understand file permissions, all fundamental skills for any computer user.</li> <li>Preparation for Advanced Challenges: Build a solid foundation that prepares players for more advanced wargames on OverTheWire and other cybersecurity challenges.</li> </ul> <p>Bandit is an ideal starting point for beginners and serves as a gateway to more complex challenges in the world of cybersecurity. It provides a hands-on, practical approach to learning that is both engaging and educational.</p>"},{"location":"bandit/docs/#where-to-start","title":"Where to start?","text":"<p>You can go there for the solution to the first challenge</p>"},{"location":"bandit/docs/#acknowledgments","title":"Acknowledgments","text":"<p>To prepare that walkthrough I decided to use another solution to keep me focused and to ensure I wasn't missing any important information, so here it is if by any mean you speak french and you'd like to check it out.</p>"},{"location":"bandit/docs/bandit0/","title":"Bandit0-&gt;1","text":""},{"location":"bandit/docs/bandit0/#level-goal","title":"Level Goal","text":"<p>The password for the next level is stored in a file called readme located in the home directory.  Use this password to log into bandit1 using SSH. Whenever you find a password for a level,  use SSH (on port 2220) to log into that level and continue the game.</p>"},{"location":"bandit/docs/bandit0/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>ls</li> <li>cat</li> </ul>"},{"location":"bandit/docs/bandit0/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Home Directory</li> <li>What is a Home Directory</li> </ul>"},{"location":"bandit/docs/bandit0/#where-to-start","title":"Where to start ?","text":"<p>We know that the password for the next level is stored in a file called readme which is located in the home directory.  First thing to know is that when we log as a user we end up in the user home directory.  That is how we know that we automatically begin in user bandit0 home directory.</p> Part 1 : Listing Files Hint <p>Why don't you look into the ls  man page to ensure that the file you're looking for is really there?</p> Solution <p>The command we are looking for is <code>ls</code>. This will allow us to list the directory files and ensure that the file we are looking for is there</p> Part 2 : Printing File <p>After running the command <code>ls</code>, you should get this output :</p> <pre><code>bandit0@bandit:~$ ls\nreadme\nbandit0@bandit:~$\n</code></pre> <p>Now we need to know how to print the contents of the readme file</p> Hint <p>Same as before, we can look into the cat man page to get to know the <code>cat</code> utility.</p> Solution <p>The command we're looking for is <code>cat readme</code>. It will allow us to retrieve the contents of the readme file.</p> Full Solution <p>The command <code>cat readme</code> will output a prompt similar to this one</p> <pre><code>bandit0@bandit:~$ cat readme\npassword_string\nbandit0@bandit:~$\n</code></pre> <p>Where password_string is a 33 alphanumeric characters password string.</p> <p>We can then copy this string with ctrl+shift+c and paste it with ctrl+shift+v</p> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit00/","title":"Bandit0","text":""},{"location":"bandit/docs/bandit00/#level-goal","title":"Level Goal","text":"<p>The goal of this level is for you to log into the game using SSH.  The host to which you need to connect is bandit.labs.overthewire.org, on port 2220.  The username is bandit0 and the password is bandit0.</p>"},{"location":"bandit/docs/bandit00/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>ssh</li> </ul>"},{"location":"bandit/docs/bandit00/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Secure Shell</li> </ul>"},{"location":"bandit/docs/bandit00/#where-to-start","title":"Where to start?","text":"<p>We know that we need to use ssh to log into the game and already know that there is only one command that may be useful to solve the challenge. After reading about what is the secure shell on wikipedia, let's dive right into it and look into the ssh man page</p> Part 1 : Host Specification <p>Our first job is to find out how to specify the host that we're trying to connect to.</p> Hint <p>Look in the ssh man page, in the DESCRIPTION section, right after the SYNOPSIS there should be, near the beginning, the name of an item that could already be found in the SYNOPSIS section</p> Solution <p>The argument we are looking for is the one name destination this argument is the host we are trying to connect to.  For now, our command looks like : <code>ssh bandit.labs.overthewire.org</code></p> Part 2 : Port Specification <p>After running this command, we can see the following prompt in the terminal :</p> <pre><code>                      This is an OverTheWire game server. \n            More information on http://www.overthewire.org/wargames\n\n!!! You are trying to log into this SSH server on port 22, which is not intended.\n\nshelltief@bandit.labs.overthewire.org: Permission denied (publickey).\n</code></pre> <p>So we need to use the port that was specified in the challenge rules</p> Hint <p>Try to look again in the SYNOPSIS and DESCRIPTION sections of the ssh man page and see if you can manage to find how to specify a port to connect to the remote host</p> Solution <p>Using the <code>-p</code> option allows us to specify a port to connect to. Our updated command ends up looking like this :  <pre><code>ssh -p 2220 bandit.labs.overthewire.org\n</code></pre></p> <p>:bulb: It is a good practice to put all option arguments before any non-option argument</p> Part 3 : Username Specification <p>Now that we specified the port to connect to, we can see the following prompt :</p> <pre><code>                         _                     _ _ _   \n                        | |__   __ _ _ __   __| (_) |_ \n                        | '_ \\ / _` | '_ \\ / _` | | __|\n                        | |_) | (_| | | | | (_| | | |_ \n                        |_.__/ \\__,_|_| |_|\\__,_|_|\\__|\n\n\n                      This is an OverTheWire game server. \n            More information on http://www.overthewire.org/wargames\n\n!!! You are trying to log into this SSH server on port 2220 with a username\n!!! that does not match the bandit game.\n\nCharystag@bandit.labs.overthewire.org's password: \n</code></pre> <p>and when we try to input the provided password : <code>bandit0</code>, we get the following response :</p> <pre><code>Permission denied, please try again.\nCharystag@bandit.labs.overthewire.org's password: \n</code></pre> <p>The important information is : with a username that does not match the bandit game. This tells us that we'll need to specify our username to successfully connect to level bandit0</p> Hint <p>Once again, you have to look into the sections SYNOPSIS and DESCRIPTION of the ssh man page. The argument you are looking for is now one that allows you to log in as a given user on a remote machine.</p> Solution <p>Using the <code>-l</code> option allows us to specify the user that we want to log into on the remote machine.  Our full command looks like : <code>ssh -p 2220 -l bandit0 bandit.labs.overthewire.org</code>. Once we get the login prompt, we can now enter the password and successfully login to the first level.</p> Full Solution <p>The full command is :</p> <pre><code>ssh -p 2220 -l bandit0 bandit.labs.overthewire.org\n</code></pre> <p>Once we get the login prompt, we can then enter the password bandit0 to successfully complete the bandit0 challenge.</p> <p>You can now solve the first level</p>"},{"location":"bandit/docs/bandit1/","title":"Bandit1-&gt;2","text":""},{"location":"bandit/docs/bandit1/#level-goal","title":"Level Goal","text":"<p>The password for the next level is stored in a file called - located in the home directory</p>"},{"location":"bandit/docs/bandit1/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>cat</li> </ul>"},{"location":"bandit/docs/bandit1/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Open a dashed filename Contains Spoilers</li> </ul>"},{"location":"bandit/docs/bandit1/#where-to-start","title":"Where to start?","text":"<p>The solution to this challenge is actually written in the Reading Material. However, if you would like more explanations.  You can open the Full Solution to the Challenge</p> Full Solution <p>After listing the contents of the directory with <code>ls</code>, we can notice the following :</p> <pre><code>bandit1@bandit:~$ ls\n-\nbandit1@bandit:~$\n</code></pre> <p>This means that the file - is actually there. However, when we try print the contents of the file with <code>cat -</code> we get  the following :</p> <pre><code>bandit1@bandit:~$ cat -\n</code></pre> <p>Where cat seems to wait for an input. By running <code>man cat</code>, we notice the following text in the Description section : With no File, or when File is -, read standard input. This tells us that cat doesn't interpret - as Filename but as a directive that tells it to read from standard input.  It will echo everything you entered on standard input once you press the ENTER key. To tell cat that you're done writting  to stdin, you can press ctrl+D (^D). This is the reason why we need to run <code>cat ./-</code> thus specifying the relative path to the file and not only its name to cat</p> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit10/","title":"Bandit10-&gt;11","text":""},{"location":"bandit/docs/bandit10/#level-goal","title":"Level Goal","text":"<p>The password for the next level is stored in the file data.txt, which contains base64 encoded data.</p>"},{"location":"bandit/docs/bandit10/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>base64</li> <li>file Optional</li> <li>head Optional</li> </ul>"},{"location":"bandit/docs/bandit10/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Base64</li> <li>Base64-encoding</li> <li>What is the base64 encoding used for StackOverflow discussion</li> </ul>"},{"location":"bandit/docs/bandit10/#where-to-start","title":"Where to start?","text":"<p>By running <code>file</code> on our file data.txt, we know that our file contains <code>ASCII text</code> we can now safely work with it. We know from the Level Goal  that our file contains base64 encoded data. Let's first run <code>head</code> on our file You should get an output close to this one : <pre><code>VGhlIHBhc3N3b3JkIGlzIHBhc3N3b3JkX3N0cmluZwo=\n</code></pre></p> <p>As the solution is pretty straightforward I will give it right away, however it will still be hidden if you want to search by yourself first. Go and  check the base64 gnu documentation page to see if you can find how to  decode our password string.</p> Full Solution <p>We will use the option <code>-d</code> (decode) of the <code>base64</code> utility. Thus, running the following command : <pre><code>base64 -d data.txt\n</code></pre> will print a string which should look like this one : <code>The password is password_string</code> to stdout.</p> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit11/","title":"Bandit11-&gt;12","text":""},{"location":"bandit/docs/bandit11/#level-goal","title":"Level Goal","text":"<p>The password for the next level is stored in the file data.txt, where all lowercase (a-z) and uppercase (A-Z) letters have been rotated by 13 positions.</p>"},{"location":"bandit/docs/bandit11/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>tr</li> <li>file Optional</li> <li>head Optional</li> </ul>"},{"location":"bandit/docs/bandit11/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>ROT13</li> <li>Rot13 Warning : Contains Spoilers</li> </ul>"},{"location":"bandit/docs/bandit11/#where-to-start","title":"Where to start?","text":"<p>By running <code>file</code> on our file data.txt, we know that our file contains <code>ASCII text</code> we can now safely work with it. We know from the Level Goal  that our file contains rot13 encoded data. Let's first run <code>head</code> on our file You should get an output close to this one : <pre><code>Gur cnffjbeq vf cnffjbeq_fgevat\n</code></pre></p> Part 1 : Describing our transformation <p>ROT13 is the rotation of all the alphabetic characters of half the alphabet (13 positions). The goal of this part is to describe the starting set and the ending set  of letters as two strings. It will be useful for translating our rotated string back to its original form.</p> Hint <p>Using the information you got about ROT13 by reading the wikipedia page and assuming that the base set is the alphabet (first the Uppercase and then the lowercase letters),  set that we will represent like this : <code>A-Za-z</code> which represents the string <code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</code>. How would you represent the set of the  translated characters by ROT13?</p> Solution <p>The set of the translated characters can be represented as <code>N-ZA-Mn-za-m</code> which is to be understood as the string <code>NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm</code></p> Part 2 : Translating our data back to its original form <p>Now that we described the starting and ending set of the ROT13 transformation, we need to know how to actually translate our data back to its original form. One thing we know from studying the rot13 behavior (and reading the wikipedia page) is that rot13 is a reciprocal cipher. Which means that rot13 applied to itself gives back the original message. Let's take our two sets of strings and see if there is a tool that could help us do the translation.</p> Hint <p>By taking a look at the section 9 of the gnu coreutils documentation, try to see we can use one of the tool described there to achieve the desired outcome.</p> Solution <p>By reading the section 9.1.2 we can see that the <code>tr</code> utility is the right tool for us. By using it with the two sets of character we deduced in the previous part and by redirecting the input from our data.txt file, we can achieve the desired outcome. Here is the full command : <pre><code>tr 'A-Za-z' 'N-ZA-Mn-za-m' &lt; data.txt\n</code></pre> Which will output something along the lines : <code>The password is password_string</code></p> Full Solution <ol> <li><code>tr 'A-Za-z' 'N-ZA-Mn-za-m' &lt; data.txt</code> is the command we use to translate our string back to its original form.</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit12/","title":"Bandit12-&gt;13","text":""},{"location":"bandit/docs/bandit12/#level-goal","title":"Level Goal","text":"<p>The password for the next level is stored in the file data.txt, which is a hexdump of a file that has been repeatedly compressed.  For this level it may be useful to create a directory under /tmp in which you can work. Use mkdir with a hard to guess directory name.  Or better, use the command \u201cmktemp -d\u201d. Then copy the datafile using cp, and rename it using mv (read the manpages!)</p>"},{"location":"bandit/docs/bandit12/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>cp</li> <li>mv</li> <li>mktemp</li> <li>tar</li> <li>gzip</li> <li>bzip2</li> <li>xxd</li> <li>file</li> </ul>"},{"location":"bandit/docs/bandit12/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Gzip</li> <li>tar</li> <li>Bzip2</li> <li>Hexdump</li> <li>GNU tar manual</li> </ul>"},{"location":"bandit/docs/bandit12/#where-to-start","title":"Where to start?","text":"<p>To prepare for our chase, we will follow the instructions and place ourselves in a temporary directory created for the occasion.  Then, we will repeatedly uncompress our data using different compression utilities until we get the password string.</p> Part 1 : Preparing for the extraction <p>To do so, we will use the mktemp utility, cd into it and cp our data.txt file to our newly created directory.</p> Hint <p>Using the 3 links to documentation pages, can you figure out how to move to a temporary directory and copy the <code>data.txt</code> file to it?</p> Solution <p>We will run the following command : <pre><code>cd \"$(mktemp -d)\" &amp;&amp; cp \"$HOME\"/data.txt .\n</code></pre> This will move us to a temporary created directory and copy the file that lies at '/home/bandit12/data.txt' to the directory we're in. We are now ready to work with this file.</p> Part 2 : Getting the binary file <p>Now that we're in a temporary directory (which we had to move to because the user bandit12 can't write to their home directory, we'll come back to file permissions in the  later challenges), we can start working with our file. The only information we have about this file is that its the hexdump of a file that has been repeatedly compressed. Running <code>file</code> on this file doesn't give us much more as it only tells us that the file we're seeing is a text file. We need a utility that can translate back the hexdump of a file  to its original form.</p> Hint <p>Looking at the hexdump and the xxd man pages, can you figure out a way to revert <code>data.txt</code> back to its original state?</p> Solution <p>The command we're going to use is the <code>xxd</code> command. To use it properly and get the original form of the data.txt file, we're going to specify the outfile we want to write to and specify <code>xxd</code> that we want it to operate in reverse mode. Here is the final command : <pre><code>xxd -r data.txt outfile\n</code></pre> Where outfile may be any name you want to give to your retrieved data.</p> Part 3 : Figuring out the procedure we're going to follow to extract all the data <p>Now that we have our binary data, I won't go step by step into the solution because even though there are quite a few steps, they ultimately can be resolved to a sequence of 3 actions. Our goal is to figure out what these 3 actions are.</p> Hint <p>By trying to extract our outfile a first time, can you figure out what the sequence of actions is? You might need to use the <code>file</code> utility to achieve that goal.</p> Solution <p>Here is the sequence of actions we need to follow to successfully extract all the data that has been compressed :</p> <ol> <li>We need to find the compression method of our file by running the <code>file</code> utility on it.</li> <li>Then, we might need to rename the file we're looking to uncompress to a file with the proper extension (as some compression utilities recognize only some specific extensions)</li> <li>We need to extract the file with the right utility and go back to step 1 until we get an ASCII Text file.</li> </ol> <p>If you're stuck at this time, go to the full solution to get the step by step walkthrough.</p> Full Solution <p>Running the following sequence of commands :</p> <pre><code>cd \"$(mktemp -d)\" &amp;&amp; cp \"$HOME\"/data.txt . || kill -INT $$\nxxd -r data.txt outfile\nfile --mime-type -b outfile # should print : application/gzip\nmv outfile outfile.gz\ngunzip outfile.gz\nfile --mime-type -b outfile # should print : application/x-bzip2\nbunzip2 outfile\nfile --mime-type -b outfile.out # should print : application/gzip\nmv outfile.out outfile.gz\ngunzip outfile.gz\nfile --mime-type -b outfile # should print : application/x-tar\ntar -xf outfile\nfile --mime-type -b data5.bin # should print : application/x-tar\ntar -xf data5.bin\nfile --mime-type -b data6.bin # should print : application/x-bzip2\nbunzip2 data6.bin\nfile --mime-type -b data6.bin.out # should print : application/x-tar\ntar -xf data6.bin.out\nfile --mime-type -b data8.bin # should print : application/gzip\nmv data8.bin data8.gz\ngunzip data8.gz\n</code></pre> <p>should fully uncompress the file data.txt. We can now run one last time the <code>file</code> command on our file data8.</p> <pre><code>file --mime-type -b data8 # should print : text/plain\n</code></pre> <p>This shows us that the data8 file contains the password we're looking for, and by running <code>cat</code> on this file, we get something along the lines : <pre><code>The password is password_string\n</code></pre></p> Bonus : One-Liner Solution <p>Instead of extracting all these files to another file and renaming that file, we could each time pipe the output of our decompression program to the <code>file</code> utility. That way it would be possible to analyse the output of the program without creating a new file each time. It is very unoptimized for huge files (as you don't know in advance what was the sequence of compressions applied thus meaning you'll have to uncompress the same file a lot of times) but it is worth mentionning as once you have this sequence, it can be very useful to have one command rather than a shell script.</p> Hint <p>Using only the man pages of the commands we used in the previous section, can you figure out a way to write a pipeline that does the exact same thing without creating any file?</p> Solution <p>The command we're looking for is the following : <pre><code>xxd -r data.txt | gunzip -c | bunzip2 -c | gunzip -c | tar --to-command='/usr/bin/tar -xO' -x | bunzip2 -c | tar -xO | gunzip -c\n</code></pre> You can understand all the options that have been added by reading the man pages of all the utilities involved.</p> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit13/","title":"Bandit13-&gt;14","text":""},{"location":"bandit/docs/bandit13/#level-goal","title":"Level Goal","text":""},{"location":"bandit/docs/bandit13/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>ssh</li> <li>scp</li> <li>ls</li> <li>chmod</li> <li>stat</li> </ul>"},{"location":"bandit/docs/bandit13/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>SSH keys</li> <li>Secure Copy Protocol</li> <li>Is using a public key to ssh any better than saving a password? security stackexchange discussion</li> <li>Password vs public key for authentication cryptography stackexchange discussion</li> <li>File Permissions</li> </ul>"},{"location":"bandit/docs/bandit13/#where-to-start","title":"Where to start?","text":"<p>First, we need to know what is in our directory. Here is the output from the <code>ls</code> command : <pre><code>bandit13@bandit:~$ ls\nsshkey.private\nbandit13@bandit:~$\n</code></pre> from now on we can already use that ssh key to connect to bandit14 user. However, we'll first retrieve the ssh key on our machine so that we can log into the user bandit14 without  the need to be logged in as the user bandit13.</p> Part 1 : Retrieval of the ssh key <p>To retrieve the ssh key using the ssh protocol, we're going to need the command that stands for secure copy, the <code>scp</code> command.</p> Hint <p>Reading the <code>scp</code> man page, can you figure out a way to retrieve the ssh key from the bandit13 user on the overthewire server?</p> Solution <p>We'll have to run the command while not connected to the remote server, as the scp protocol will connect to the remote server and retrieve the file for us. From the scp man page, we know the following : \"The source and target may be specified as a local pathname, a remote host with optional path in the form [user@]host:[path], or a URI in the form scp://[user@]host[:port][/path]. Local file names can be made explicit using absolute or relative pathnames to avoid scp treating file names containing \u2018:\u2019 as host specifiers.\". One precision to add is that the <code>path</code> argument is starting from the user's home directory.</p> <p>Thus we can deduce the structure of the call we have to make : - For the source, we will specify the URI as follows : <code>scp://bandit13@bandit.labs.overthewire.org:2220/sshkey.private</code> - For the target, we will specify the local pathname we want to store the file in, let's say : <code>./bandit14_sshkey</code></p> <p>Thus, the command we're looking for is : <pre><code>scp scp://bandit13@bandit.labs.overthewire.org:2220/home/bandit13/sshkey.private ./bandit14_sshkey\n</code></pre></p> Part 2 : Setting the right file permissions <p>Now that we have a private ssh key, we need to use it to connect other ssh. To do so, as it is a private ssh key, it must meet some requirements on the file permissions. Our goal is to set the proper file permissions for us to be allowed to connect to the user bandit14.</p> Hint <p>By looking into the FILES section of the ssh man page and the chmod gnu documentation page, can you figure out the proper file permissions for the private key and set them accordingly?</p> Solution <p>In the portion describing the file <code>~/.ssh/id_rsa</code>, we can read that this file should be readable by the user and should not be accessible by others. Running the <code>stat</code> utility on the file gives us the file permissions of our ssh private key. Here is the output from this command :</p> <pre><code>  File: bandit14_sshkey\n  Size: 1679        Blocks: 8          IO Block: 4096   regular file\nDevice: 804h/2052d  Inode: 8913955     Links: 1\nAccess: (0640/-rw-r-----)  Uid: ( 1001/ Charystag)   Gid: ( 1001/ Charystag)\nAccess: 2024-06-03 21:05:42.285372019 +0200\nModify: 2024-06-03 21:05:11.765802230 +0200\nChange: 2024-06-03 21:05:11.765802230 +0200\n Birth: 2024-06-03 21:05:11.733802682 +0200\n</code></pre> <p>We can now see, (helping ourselves from the documentation about file permissions) that this file is readable and writable by the user and readable by the other members of the user's group. As we don't need to write data to the private key file, we can restrict the permissions to the minimum, we'll only allow the current user (us) to write to the file. The following call to the <code>chmod</code> utility will allow us to achieve our goal : <code>chmod 400 bandit14_sshkey</code>.</p> Part 3 : Connecting using the ssh key <p>Now that the proper file permissions are set, the last thing we need to do is to connect to the user bandit14 using our private ssh key.</p> Hint <p>Going back into the <code>ssh(1)</code> man page, can you figure out an option that would allow us to use the ssh key we just got to connect to the user bandit14 ?</p> Solution <p>The option we're looking for is the option <code>-i</code> which allows us to use our identity_file to connect without the need for a password. This is our full command :</p> <pre><code>ssh -p 2220 -l bandit14 -i bandit14_sshkey bandit.labs.overthewire.org\n</code></pre> Full Solution <ol> <li><code>scp scp://bandit13@bandit.labs.overthewire.org:2220/home/bandit13/sshkey.private ./bandit14_sshkey</code> to retrieve the private ssh key from the bandit13 user</li> <li><code>chmod 400 bandit14_sshkey</code> to set the right file permissions and allow us to connect over ssh</li> <li><code>ssh -i bandit14_sshkey ssh://bandit14@bandit.labs.overthewire.org:2220</code> to finally connect to user bandit14</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit14/","title":"Bandit14-&gt;15","text":""},{"location":"bandit/docs/bandit14/#level-goal","title":"Level Goal","text":"<p>The password for the next level can be retrieved by submitting the password of the current level to port 30000 on localhost.</p>"},{"location":"bandit/docs/bandit14/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>nc</li> <li>nmap</li> </ul>"},{"location":"bandit/docs/bandit14/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Netcat</li> <li>Nmap</li> <li>Port Computing</li> <li>Localhost</li> <li>Ip address</li> <li>Ip address Wikipedia</li> <li>Ip address basics</li> </ul>"},{"location":"bandit/docs/bandit14/#where-to-start","title":"Where to start?","text":"<p>We have to start by reading a lot of documentation, to understand a bit more what we have to do and what we're talking about.  First things first, before even trying to send the password, we need to retrieve it first.</p> Part 1 : Password retrieval <p>We need to retrieve the password by finding in which file it is stored, the information for the password file is actually displayed at the beginning of each level, when we connect to the user we're accessing over ssh.</p> Hint <p>By using the prompt we get when logging in to bandit14 (or any other overthewire user), can you figure out where is the password for bandit14 stored?</p> Solution <p>Let's start by recalling the instructions for each level : <pre><code>  This machine might hold several wargames.\n  If you are playing \"somegame\", then:\n\n    * USERNAMES are somegame0, somegame1, ...\n    * Most LEVELS are stored in /somegame/.\n    * PASSWORDS for each level are stored in /etc/somegame_pass/.\n</code></pre> This tells us that the password we're looking for is in the file <code>/etc/bandit_pass/bandit14</code>. Let's run a quick <code>stat</code> on this file  to ensure we can read it. Here is the output from this command : <pre><code>  File: /etc/bandit_pass/bandit14\n  Size: 33          Blocks: 8          IO Block: 4096   regular file\nDevice: 10301h/66305d   Inode: 517564      Links: 1\nAccess: (0400/-r--------)  Uid: (11014/bandit14)   Gid: (11014/bandit14)\nAccess: 2024-06-03 22:30:53.614318247 +0000\nModify: 2023-10-05 06:19:04.167222286 +0000\nChange: 2023-10-05 06:19:04.167222286 +0000\n Birth: 2023-10-05 06:19:04.167222286 +0000\n</code></pre> As we're logged in as user <code>bandit14</code>, we know we can access this file which contains the 33 bytes password string we need to complete this level.</p> Part 2 : Port scanning <p>We know that there is a service listening on port 30000, let's start by scanning the port 30000 to get a better idea of how to communicate with the service listening on port 30000.</p> Hint <p>Using only the description section of the nmap man page, can you figure out how to scan the localhost network in order to see which ports are in use?</p> Solution <p>The command we're looking for is <code>nmap localhost</code>, which will allow us to scan the network at 127.0.0.1. Here is the output from this command : <pre><code>bandit14@bandit:~$ nmap localhost\nStarting Nmap 7.80 ( https://nmap.org ) at 2024-06-04 10:17 UTC\nNmap scan report for localhost (127.0.0.1)\nHost is up (0.00022s latency).\nNot shown: 993 closed ports\nPORT      STATE SERVICE\n22/tcp    open  ssh\n1111/tcp  open  lmsocialserver\n1122/tcp  open  availant-mgr\n1840/tcp  open  netopia-vo2\n4321/tcp  open  rwhois\n8000/tcp  open  http-alt\n30000/tcp open  ndmps\n\nNmap done: 1 IP address (1 host up) scanned in 0.11 seconds\nbandit14@bandit:~$\n</code></pre> We can see that the port 30000 is open and accepts tcp connections. This tells us that we need to send the password using the tcp protocol.</p> Part 3 : Password sending <p>Now that we know that we need to send the password using the tcp protocol, we need a tool that is able to do that for us. Here is when the <code>nc</code> tool comes in handy.</p> Hint <p>By using the TALKING TO SERVERS section of the <code>nc(1)</code> man page, can you figure out how to send the password to the server?</p> Solution <p><code>nc</code> will have to read the password from stdin to send it to the server, there are a few ways to do so but one command you could run is the following : <pre><code>nc localhost 30000 &lt; /etc/bandit_pass/bandit14\n</code></pre> which redirects stdin from the file containing the pasword for user bandit 14. Once this is done, you should see the following output : <pre><code>bandit14@bandit:~$ nc localhost 30000 &lt; /etc/bandit_pass/bandit14\nCorrect!\npassword_string\n\nbandit14@bandit:~$\n</code></pre> where pasword_string is our 33 bytes characters password string.</p> Full Solution <ol> <li><code>cat /etc/bandit_pass/bandit14 | nc localhost 30000</code> to send the password to the service listening at localhost:30000.</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit15/","title":"Bandit15-&gt;16","text":""},{"location":"bandit/docs/bandit15/#level-goal","title":"Level Goal","text":"<p>The password for the next level can be retrieved by submitting the password of the current level to port 30001 on localhost using SSL encryption.</p> <p>Helpful note: Getting \u201cHEARTBEATING\u201d and \u201cRead R BLOCK\u201d? Use -ign_eof and read the \u201cCONNECTED COMMANDS\u201d section in the manpage.  Next to \u2018R\u2019 and \u2018Q\u2019, the \u2018B\u2019 command also works in this version of that command\u2026</p>"},{"location":"bandit/docs/bandit15/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>s_client</li> </ul>"},{"location":"bandit/docs/bandit15/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>OpenSSL Cookbook</li> <li>OpenSSL Wikipedia Page</li> <li>Transport Layer Security</li> </ul>"},{"location":"bandit/docs/bandit15/#where-to-start","title":"Where to start?","text":"<p>For the network analysis and password retrieval, you can go to the previous challenge. In this challenge  I'm only going to show how to use the <code>s_client</code> command from the <code>openssl</code> program to efficiently  communicate with our server.</p> Part 1 : Communicating with the SSL server <p>Our first goal is to lean how to open a connection with our SSL server, to do so we are going to use the s_client command.</p> Hint <p>By looking at the s_client man page and only looking for the fields that talk about connecting to the SSL server, can you figure out a way to open a connection with the server? The server will read all its input from stdin</p> Solution <p>By running the command <code>openssl s_client localhost:30001</code> or <code>openssl s_client -connect localhost:30001</code>, you can open a connection with the server.</p> Part 2 : Sending the password to the server using the client <p>Now that we've opened a connection to the server, we want to send the password. We could copy and paste the password, press enter and then ^C the client and it would actually work but this is not what we are going to do here.</p> <p>As the password is contained within the file <code>/etc/bandit_pass/bandit15</code>, it would be way easier to just redirect the input from that file. However, when we do it like this, no password appears on the standard output. Our goal is to fix that issue.</p> Hint <p>By looking at the CONNECTED COMMANDS section of the s_client man page, try to understand why we can observe such a behavior and then, look at the OPTIONS section to see if you can retrieve an option that will fix this behavior.</p> Solution <p>We can observe such behavior because at the end of any file, there is an EOF character that is interpreted by our <code>s_client</code> command as a signal to close the connection. By using the option <code>-ign_eof</code> we can explicitely tell <code>s_client</code> to keep the connection open, and thus receive the password from the server. Here is our final command : <pre><code>openssl s_client -ign_eof localhost:30001 &lt; /etc/bandit_pass/bandit15\n</code></pre></p> Full Solution <ol> <li><code>openssl s_client -quiet localhost:30001 &lt; /etc/bandit_pass/bandit15</code> to retrieve the password from the SSL server</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit16/","title":"Bandit16-&gt;17","text":""},{"location":"bandit/docs/bandit16/#level-goal","title":"Level Goal","text":"<p>The credentials for the next level can be retrieved by submitting the password of the current level to a port on localhost in the range 31000 to 32000.  First find out which of these ports have a server listening on them. Then find out which of those speak SSL and which don\u2019t.  There is only 1 server that will give the next credentials, the others will simply send back to you whatever you send to it.</p>"},{"location":"bandit/docs/bandit16/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>nmap</li> <li>nc Optionnal</li> </ul>"},{"location":"bandit/docs/bandit16/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Port Scanner</li> <li>Nmap commands</li> </ul>"},{"location":"bandit/docs/bandit16/#where-to-start","title":"Where to start?","text":"<p>What we need to do here is to find a way to scan the network so we know on which port the server we need to talk to resides. First, let's  scan the network between the port 31000 and 32000. To do so, we can use two utilities, <code>nmap</code> and <code>nc</code></p> Part 1 : Basic Port Scanning with nc Hint <p>By lookint at the PORT SCANNING section of the nc man page, can you figure out a way to perform a basic scan of the ports between 31000 and 32000 with <code>nc</code>?</p> Solution <p>With <code>nc</code>, we can use the following command : <pre><code>nc -zv localhost 31000-32000 |&amp; grep -v -E '^nc'\n</code></pre> Let's break down how it works :</p> <ol> <li><code>nc -zv localhost 31000-32000</code> tells nc to report the open ports between the port 31000 and 32000, writing verbose output to stderr</li> <li><code>|&amp;</code> is a metacharacter that is equivalent to <code>2 &gt;&amp; 1 |</code> which means to redirect stdout and stderr through a pipe (see pipelines in the gnu bash manual for more information)</li> <li><code>grep -v -E '^nc'</code> uses the regular expression <code>^nc</code> to mach lines beginning by 'nc' and the <code>-v</code> option uses the inverted match to match only the lines that don't begin with nc (meaning the only lines that didn't report an error).</li> </ol> <p>Here is the output from this command : <pre><code>bandit16@bandit:~$ nc -zv localhost 31000-32000 |&amp; grep -v -E '^nc'\nConnection to localhost (127.0.0.1) 31046 port [tcp/*] succeeded!\nConnection to localhost (127.0.0.1) 31518 port [tcp/*] succeeded!\nConnection to localhost (127.0.0.1) 31691 port [tcp/*] succeeded!\nConnection to localhost (127.0.0.1) 31790 port [tcp/*] succeeded!\nConnection to localhost (127.0.0.1) 31960 port [tcp/*] succeeded!\nbandit16@bandit:~$\n</code></pre></p> Part 2 : Basic Port Scanning with nmap Hint <p>By using the PORT SPECIFICATION AND SCAN ORDER section of the nmap man page, can you figure out a way to perform a basic scan of the ports between 31000 and 32000 with <code>nmap</code>?</p> Solution <p>With <code>nmap</code>, it is even more simple. We just need to provide the range of ports to scan as nmap is already a port scanner.</p> <p>Here is the command we're looking for : <pre><code>nmap localhost -p 31000-32000\n</code></pre> Here is the output from this command : <pre><code>Starting Nmap 7.80 ( https://nmap.org ) at 2024-06-04 14:27 UTC\nNmap scan report for localhost (127.0.0.1)\nHost is up (0.00013s latency).\nNot shown: 996 closed ports\nPORT      STATE SERVICE\n31046/tcp open  unknown\n31518/tcp open  unknown\n31691/tcp open  unknown\n31790/tcp open  unknown\n31960/tcp open  unknown\n\nNmap done: 1 IP address (1 host up) scanned in 0.05 seconds\n</code></pre></p> Part 3 : Service detection with nmap <p>Now that we have a little more info about the open ports, we can now run a more advance scan using <code>nmap</code> on the open ports we found.</p> Hint <p>By taking a look at the SERVICE AND VERSION DETECTION section of the nmap man page, can you figure out how to know on which port resides the service we want to communicate with ?</p> Solution <p>The <code>-sV</code> option is the option we're looking for, it will allow us to identify the service that lies on each port that we're scanning. As the scan doesn't need to be full (as 4 out of 5 of these services will echo back to the sender all the information they receive), we will enable the option <code>--version-light</code> so that the scan takes less time.</p> <p>The command we're looking for is the following : <pre><code>nmap -sV --version-light -p 31046,31518,31691,31790,31960 localhost\n</code></pre> We could of course, also run this command on the whole set of ports between the range 31000 and 32000 with <code>nmap -sV --version-light -p 31000-32000</code>.</p> <p>Here is the output from this command (<code>--version-light</code> is an alias for <code>--version-intensity 2</code>): <pre><code>bandit16@bandit:~$ nmap -sV --version-intensity 2 localhost -p 31046,31518,31691,31790,31960\nStarting Nmap 7.80 ( https://nmap.org ) at 2024-06-04 14:38 UTC\nNmap scan report for localhost (127.0.0.1)\nHost is up (0.00013s latency).\n\nPORT      STATE SERVICE     VERSION\n31046/tcp open  echo\n31518/tcp open  ssl/echo\n31691/tcp open  echo\n31790/tcp open  ssl/unknown\n31960/tcp open  echo\n1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :\nSF-Port31790-TCP:V=7.80%T=SSL%I=2%D=6/4%Time=665F2708%P=x86_64-pc-linux-gn\nSF:u%r(GenericLines,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20cur\nSF:rent\\x20password\\n\")%r(GetRequest,31,\"Wrong!\\x20Please\\x20enter\\x20the\\\nSF:x20correct\\x20current\\x20password\\n\")%r(SSLSessionReq,31,\"Wrong!\\x20Ple\nSF:ase\\x20enter\\x20the\\x20correct\\x20current\\x20password\\n\")%r(TLSSessionR\nSF:eq,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20current\\x20passwo\nSF:rd\\n\");\n\nService detection performed. Please report any incorrect results at https://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 32.61 seconds\nbandit16@bandit:~$\n</code></pre> We know now that we can use the <code>s_client</code> command to send the password to the server listening at 31790 and retrieve the ssh key to connect to bandit 17.</p> Full Solution <ol> <li><code>nmap -sV --version-light -p 31000-32000</code> to retrieve the server that is listening for our password</li> <li><code>openssl s_client -ign_eof localhost:31790 &lt; /etc/bandit_pass/bandit16</code> to retrieve the private ssh key needed to connect to bandit 17.</li> </ol> Bonus : Writting the ssh key directly to a file <p>Wouldn't it be way more suitable to output our ssh key directly to a file? Fortunately, there is an easy way to do so.</p> Hint <p>Searching again into the <code>s_client</code> man page, can you figure out a way to output the <code>ssh_key</code> directly to a file ?</p> Solution <p>First, we need to create a file to store the private ssh key, we'll create it using the mktemp utility. Then, using the <code>-sess_out</code> option we will be able to output our ssl session (which is the ssh key) directly to the file.</p> <p>This is what our set of commands look like : <pre><code>PRIVATE_KEY=\"$(mktemp)\"\nopenssl s_client -ign_eof -sess_out \"$PRIVATE_KEY\" localhost:31790 &lt; /etc/bandit_pass/bandit16`\n</code></pre> Then we can run <code>echo \"$PRIVATE_KEY\"</code> to get the name of the file and use the scp command to retrieve the file on our machine.</p> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit17/","title":"Bandit17-&gt;18","text":""},{"location":"bandit/docs/bandit17/#level-goal","title":"Level Goal","text":"<p>There are 2 files in the homedirectory: passwords.old and passwords.new.  The password for the next level is in passwords.new and is the only line that has been changed between  passwords.old and passwords.new.</p> <p>NOTE: if you have solved this level and see \u2018Byebye!\u2019 when trying to log into bandit18, this is related to the next level, bandit19.</p>"},{"location":"bandit/docs/bandit17/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>diff</li> </ul>"},{"location":"bandit/docs/bandit17/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>diff Wikipedia page</li> </ul>"},{"location":"bandit/docs/bandit17/#where-to-start","title":"Where to start?","text":"<p>We know that there are two files in our directory that we can view with the <code>ls</code> command : passwords.old and passwords.new, we are going to need  to output the difference between those two files. We know that the new password is the line that has been updated in the passwords.new file.</p> Part 1 : Output the diff of the files <p>We want to see the differences between both files printed to standard output.</p> Hint <p>By looking at the diff man page, can you figure out how to use the <code>diff(1)</code> utility to output the differences between these two files?</p> Solution <p>To do so, we simply need to run the following command : <pre><code>diff passwords.old passwords.new\n</code></pre> The lines that are different in passwords.old (the first argument) will appear prefixed by the symbol <code>&lt;</code> while the lines different in passwords.new will appear prefixed by a <code>&gt;</code>. The password is the line that is different in passwords.new</p> Part 2 : Making diff output a bit more readable <p>Right now, we need to remember that the different lines from the first file will be prefixed by <code>&lt;</code> and the ones from the second file by <code>&gt;</code>. Let's find a way to make the output more readable so that we don't need to remember this information.</p> Hint <p>Looking more deeply into the diff man page, can you figure out a way to make the output more readable ?</p> <p>They are a lot more than one answer.</p> Solution <p>For example, one could use the option <code>-u</code> to print a string at the beginning of the <code>diff</code> output which will look like the one below : <pre><code>--- passwords.old   2023-10-05 06:19:27.827277353 +0000\n+++ passwords.new   2023-10-05 06:19:27.835277371 +0000\n</code></pre> which means that all the lines from passwords.old will be prefixed by <code>-</code> and the lines from passwords.new will be prefixed by <code>+</code>. The <code>diff -u</code> output will be the following : <pre><code>--- passwords.old   2023-10-05 06:19:27.827277353 +0000\n+++ passwords.new   2023-10-05 06:19:27.835277371 +0000\n@@ -39,7 +39,7 @@\n WFB9ezoSnb146RUbbX6d9Yx2sU46Q8Ax\n JFkUvvpfLmE7KBkAEePwZndBr33oFzh8\n wDn38KGxWKk7dp39odF7fWLT6aljqEsK\n-old_password\n+new_password\n RKMlN2JZydt4j5rQjJt07GgNqtgnq8dw\n nssByafsRMwebfyRhMWKSqX39xF1l4Hr\n ZlUzDUTd4faumV8wCtJ4CHA788tySKDO\n</code></pre> We can then use the new password to go to the following level.</p> Full Solution <ol> <li><code>diff passwords.old passwords.new</code> to output the differences between the two files and retrieve the new password from the passwords.new file.</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit18/","title":"Bandit18-&gt;19","text":""},{"location":"bandit/docs/bandit18/#level-goal","title":"Level Goal","text":"<p>The password for the next level is stored in a file readme in the homedirectory.  Unfortunately, someone has modified .bashrc to log you out when you log in with SSH.</p>"},{"location":"bandit/docs/bandit18/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>ssh</li> <li>cat</li> </ul>"},{"location":"bandit/docs/bandit18/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>What is the purpose of .bashrc Unix StackExchange discussion</li> <li>Bash invocation</li> <li>Difference between login shell and non-login shell Unix StackExchange discussion</li> </ul>"},{"location":"bandit/docs/bandit18/#where-to-start","title":"Where to start?","text":"<p>We know that someone has modified our <code>.bashrc</code> file in order to log us out when we log in using SSH. The <code>.bashrc</code> file is a file where commands are read from when bash  is invoked as an interactive shell that is not a login shell (see bash invocation for more informations). What we are going to do is to find out how to retrieve the <code>readme</code> file from bandit18 home directory.</p> Part 1 : Running a command on the remote host <p>As we are anyway login in using the ssh protocol, we need to find a way to run a command non-interactively on the remote host.</p> Hint <p>Once again, look into the ssh man page, find a way to execute a command on the remote host instead of an interactive shell.</p> Solution <p>To do so, we just need to append the command we want to run at the end of our ssh command, it will then be run instead of an interactive shell when we log in into the user bandit18. Our ssh command is the following : <pre><code>ssh -l bandit18 -p 2220 bandit.labs.overthewire.org cat readme\n</code></pre> Because we need to <code>cat</code> the readme file in bandit18 home directory. It will print the password string to sdout and exit.</p> Full Solution <ol> <li><code>ssh ssh://bandit18@bandit.labs.overthewire.org:2220 cat readme</code> to cat the readme file in bandit18 home directory.</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit19/","title":"Bandit19-&gt;20","text":""},{"location":"bandit/docs/bandit19/#level-goal","title":"Level Goal","text":"<p>To gain access to the next level, you should use the setuid binary in the homedirectory.  Execute it without arguments to find out how to use it.  The password for this level can be found in the usual place (/etc/bandit_pass), after you have used the setuid binary.</p>"},{"location":"bandit/docs/bandit19/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>cat</li> </ul>"},{"location":"bandit/docs/bandit19/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>setuid on wikipedia</li> <li>setUID and getUID bits</li> <li>Difference between euid and uid StackOverflow Discussion</li> </ul>"},{"location":"bandit/docs/bandit19/#where-to-start","title":"Where to start?","text":"<p>The only thing we have in our directory is an executable called <code>bandit20-do</code>, the instructions for this level tell us that we should  execute it without arguments to find out how to use it.</p> Part 1 : Using the setuid binary <p>When running the executable without arguments, we see the following : <pre><code>Run a command as another user.\n  Example: ./bandit20-do id\n</code></pre> We need to find out how to use this executable to print the password for the next level on stdout.</p> Hint <p>Using the example of the <code>bandit20-do</code> executable, can you figure out the command to execute to print the bandit20 password to stdout?</p> Solution <p>When running the example, we can see the following output : <pre><code>bandit19@bandit:~$ ./bandit20-do id\nuid=11019(bandit19) gid=11019(bandit19) euid=11020(bandit20) groups=11019(bandit19)\nbandit19@bandit:~$\n</code></pre> We can see that our effective user id (euid) is bandit20 when we run this executable, which means that we can do everything that the user bandit20 can do.</p> <p>By running the stat command on the file <code>/etc/bandit_pass/bandit20</code> we see the following output : <pre><code>  File: /etc/bandit_pass/bandit20\n  Size: 33          Blocks: 8          IO Block: 4096   regular file\nDevice: 10301h/66305d   Inode: 517599      Links: 1\nAccess: (0400/-r--------)  Uid: (11020/bandit20)   Gid: (11020/bandit20)\nAccess: 2024-06-04 21:38:04.747961484 +0000\nModify: 2023-10-05 06:19:06.591227890 +0000\nChange: 2023-10-05 06:19:06.595227900 +0000\n Birth: 2023-10-05 06:19:06.591227890 +0000\n</code></pre> This tells us that the file is only readable by the user bandit20, however thanks to the <code>bandit20-do</code> executable, we are the user bandit20. We can thus <code>cat</code> this file and retrieve the password string. Here is the final command : <pre><code>./bandit20-do cat /etc/bandit_pass/bandit20\n</code></pre></p> Full Solution <ol> <li><code>./bandit20-do cat /etc/bandit_pass/bandit20</code> to print the password string on stdout.</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit2/","title":"Bandit2-&gt;3","text":""},{"location":"bandit/docs/bandit2/#level-goal","title":"Level Goal","text":"<p>The password for the next level is stored in a file called spaces in this filename located in the home directory</p>"},{"location":"bandit/docs/bandit2/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>ls</li> <li>cat</li> <li>bash</li> </ul>"},{"location":"bandit/docs/bandit2/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Filenames Spaces Linux Contains Spoilers</li> </ul>"},{"location":"bandit/docs/bandit2/#where-to-start","title":"Where to start?","text":"<p>For this level again, the solution is written in the helpful material. For more explanations, you can read the Walkthrough.</p> Part 1 : Analysing the directory files <p>After listing the contents of the directory with <code>ls</code>, we can notice the following :</p> <pre><code>bandit2@bandit:~$ ls\nspaces in this filename\nbandit2@bandit:~$\n</code></pre> <p>Which seems to indicate that there are 4 files in this directory : <code>spaces</code>, <code>in</code>, <code>this</code> and <code>filename</code>. </p> <p>Let's look into the ls man page,  and try to look for an option that lists one file per line.</p> Hint <p>Options can also be numbers</p> Solution <p>The <code>-1</code> option is the option we were looking for</p> <p>However when using the option we previously found we see the following :</p> <pre><code>bandit2@bandit:~$ ls -1\nspaces in this filename\nbandit2@bandit:~$ \n</code></pre> <p>which is exactly the same prompt as before. However, as this option allows us to list one file per line, we know  for sure that <code>spaces in this filename</code> is actually the name of a unique file.</p> Part 2 : Printing the file <p>Now that we know that the file is called <code>spaces in this filename</code>, we need to refer find a way to print this file. </p> Hint <p>By looking into the QUOTING section of the gnu bash manual,  can you retrieve all the quoting mechanism that are available to us in order to print this file?</p> Solution <p>There are 3 quoting mechanism that allow us to print this file : </p> <ol> <li> <p>By escaping the spaces with the filename : <code>spaces\\ in\\ this\\ filename</code>. As the <code>\\</code> preserves the litteral value of the  character immediately following it.</p> </li> <li> <p>By enclosing the filename within simple quotes : <code>'spaces in this filename'</code>. As the simple quotes preserve the litteral  value of all the characters they enclose</p> </li> <li> <p>By enclosing the filename within double quotes : <code>\"spaces in this filename\"</code>. As the double quotes preserve the litteral  value of all the characters they enclose, appart from <code>$</code>, <code>`</code> and <code>\\</code>. As the character we need to preserve is the space,  we can also use the double quotes to achieve this goal.</p> </li> </ol> Full Solution <ol> <li><code>cat \"spaces in this filename\"</code> to print the password to stdout.</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit20/","title":"Bandit20-&gt;21","text":""},{"location":"bandit/docs/bandit20/#level-goal","title":"Level Goal","text":"<p>There is a setuid binary in the homedirectory that does the following: it makes a connection to localhost on the port you specify  as a commandline argument. It then reads a line of text from the connection and compares it to the password in the previous level (bandit20).  If the password is correct, it will transmit the password for the next level (bandit21).</p> <p>NOTE: Try connecting to your own network daemon to see if it works as you think</p>"},{"location":"bandit/docs/bandit20/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>nc</li> <li>bash</li> </ul>"},{"location":"bandit/docs/bandit20/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Bash Job Control</li> <li>List of Commands</li> <li>How to move a running process to background UNIX StackOverflow Discussion</li> </ul>"},{"location":"bandit/docs/bandit20/#where-to-start","title":"Where to start?","text":"<p>We can start this level by running the executable <code>su_connect</code> without any argument to try and get a better feel of what we should do with this program.</p> <p>Here is the output from this command : <pre><code>Usage: ./suconnect &lt;portnumber&gt;\nThis program will connect to the given port on localhost using TCP. If it receives the correct password from the other side, the next password is transmitted back.\n</code></pre> What we can deduce at this moment is that the program <code>suconnect</code> is a TCP client, this means that we need to set up a server in order for our <code>suconnect</code> client to communicate with.</p> Part 1 : Setting up a TCP server that sends the password <p>The first part of this challenge is to set up a TCP server that we will use to send the password to any host that would be trying to connect.</p> Hint <p>Using the CLIENT/SERVER MODEL of the nc command, can you figure out a way to set up a server that will listen for incoming connections and send the password to any client that connects to it?</p> Solution <p>Let's copy the exact same code from the <code>nc</code> man page example. Here is the command we're going to use : <pre><code>nc -l 1234\n</code></pre> We can now notice that we have an open TCP server that listens for incoming connections. However our server is pretty basic (as it does absolutely nothing), however it can communicate through its standard input and output. Let's try to redirect the standard input of the server from a file.</p> <p>By running the following command : <pre><code>nc -l 1234 &lt; /etc/bandit_pass/bandit20\n</code></pre> We have a server listening on the port 1234 that will send the password for bandit20 to any host that tries to connect to it.</p> Part 2 : Running the TCP server as a background process <p>After running our command, we can notice that the TCP server is waiting and that we won't have any access to our terminal while the server is still running. Our goal here is to find a way to keep the server open and to communicate with it using the same terminal session.</p> Hint <p>By using the Helpful Reading Material, can you figure out a way to run our server as a background process so that you can continue communicating with the server using your current terminal session?</p> Solution <p>To continue communicating with the server using the current terminal session, we need to launch it as a background process, this means that the exit status of our command will be 0 and that <code>bash</code> won't wait for the completion of your command to give us back the control of our terminal session.</p> <p>Here is the command we're going to execute. <pre><code>nc -l 1234 &lt; /etc/bandit_pass/bandit20 &amp;\n</code></pre> It will tell bash to run this process as a background process, which will allow us to run our TCP client to retrieve the password for the next level.</p> Part 3 : Communicating with our server <p>Now that we have a server running and listening on the port 1234, we can use our executable to communicate with it. This part is pretty straightforward so there won't be any Hint.</p> Solution <p>We just need to run the executable <code>suconnect</code> and to specify it the right port number.</p> <p>Here is the output from that command : <pre><code>bandit20@bandit:~$ ./suconnect 1234\nRead: bandit20_pass\nPassword matches, sending next password\nbandit21_pass\n[1]+  Done                    nc -l 1234 &lt; /etc/bandit_pass/bandit20\nbandit20@bandit:~$\n</code></pre> You can see that on the last line, bash reports that the our server in the background has returned as it closes after receiving one connection.</p> Full Solution <ol> <li><code>nc -l port_number &lt; /etc/bandit_pass/bandit20 &amp;</code> to run a server listing on port_number in the background.</li> <li><code>./suconnect port_number</code> to retrieve the password for the next level.</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit21/","title":"Bandit21-&gt;22","text":""},{"location":"bandit/docs/bandit21/#level-goal","title":"Level Goal","text":"<p>A program is running automatically at regular intervals from cron, the time-based job scheduler.  Look in /etc/cron.d/ for the configuration and see what command is being executed.</p>"},{"location":"bandit/docs/bandit21/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>cron</li> <li>crontab(5)</li> <li>crontab(1)</li> </ul>"},{"location":"bandit/docs/bandit21/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>cron Wikipedia page</li> <li>Understanding crontab in Linux with examples</li> <li>crontab in Linux with examples Geekforgeeks article</li> </ul>"},{"location":"bandit/docs/bandit21/#where-to-start","title":"Where to start?","text":"<p>We are now starting a series of levels based on <code>cron</code>, which is a job scheduler on Linux. For this series, we are going  to need to analyse the cron jobs for the users involved in this series of level and see what we informations we can gather  from this analysis. Let's start with the level21.</p> Part 1 : Retrieving the cronjob for the user bandit22 <p>Our goal here is to know which script is executed by the cronjob on the session of user bandit22.</p> Hint <p>By analysing the files into the <code>/etc/cron.d</code> directory, can you retrieve the contents of the script that runs for the bandit22 user?</p> Solution <p>Here is the output from the <code>ls</code> command for the <code>/etc/crond.d</code> directory : <pre><code>bandit21@bandit:~$ ls /etc/cron.d\ncronjob_bandit15_root  cronjob_bandit17_root  cronjob_bandit22  cronjob_bandit23  cronjob_bandit24  cronjob_bandit25_root  e2scrub_all  otw-tmp-dir  sysstat\nbandit21@bandit:~$\n</code></pre> We see that there is a file named <code>cronjob_bandit22</code> in the directory. Let's <code>cat</code> the contents of this file : <pre><code>bandit21@bandit:~$ cat /etc/cron.d/cronjob_bandit22\n@reboot bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/null\n* * * * * bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/null\nbandit21@bandit:~$\n</code></pre> This shows us that there is a cronjob running every minute for the user bandit22. We are going to go on and print the contents of the script : <pre><code>bandit21@bandit:~$ cat /usr/bin/cronjob_bandit22.sh \n#!/bin/bash\nchmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv\ncat /etc/bandit_pass/bandit22 &gt; /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv\nbandit21@bandit:~$\n</code></pre> This finally tells us that the password for the user bandit22 is stored in the temporary file which name is written in the script and that is readable by everyone.</p> <p>We can go on and finally retrieve this password to jump to the next level.</p> Full Solution <ol> <li><code>cat /etc/cron.d/cronjob_bandit22</code> to know which cron job is executed for the user bandit22.</li> <li><code>cat /usr/bin/cronjob_bandit22.sh</code> to view the contents of the script that the cron job for user bandit22 runs</li> <li><code>cat tmpfile</code> to print the password string on stdout.</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit22/","title":"Bandit22-&gt;23","text":""},{"location":"bandit/docs/bandit22/#level-goal","title":"Level Goal","text":"<p>A program is running automatically at regular intervals from cron, the time-based job scheduler.  Look in /etc/cron.d/ for the configuration and see what command is being executed.</p> <p>NOTE: Looking at shell scripts written by other people is a very useful skill.  The script for this level is intentionally made easy to read.  If you are having problems understanding what it does, try executing it to see the debug information it prints.</p>"},{"location":"bandit/docs/bandit22/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>whoami</li> <li>md5sum</li> <li>cut</li> </ul>"},{"location":"bandit/docs/bandit22/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Command Substitution in bash</li> <li>MD5 message-digest algorithm</li> </ul>"},{"location":"bandit/docs/bandit22/#where-to-start","title":"Where to start?","text":"<p>To know how to retrieve the script for this level, you can refer to the previous level. We will focus only on the script analysis for this challenge</p> Part 1 : Script analysis and password retrieval <p>When we retrieve the script from the file <code>/usr/bin/cronjob_bandit23.sh</code>, we can see that it defines two variables and that it uses them to print the password for the next level into a file in the <code>/tmp</code> directory.</p> Hint <p>Using the useful commands, can you figure out what the script does and in which file it prints the password for the next level?</p> Solution <p>Let's analyse this script.</p> <ul> <li>The <code>myname</code> variable hold the output of the command <code>whoami</code>, which prints the username associated with the current user id. As this script is ran by bandit23, we know that the value of the myname variable is bandit23.</li> <li>The <code>mytarget</code> variable holds the output of the following pipeline (where <code>myname</code> has been replaced by its value) : <code>echo I am user bandit23 | md5sum | cut -d ' ' -f 1</code>.</li> </ul> <p>The <code>md5sum</code> utility will hash the phrase it receives on standard input and output something following this format : <pre><code>hashed_phrase filename\n</code></pre> with hashed_phrase and filename separated by a space (here filename is <code>-</code> because the file is standard input). Finally, the cut utility will retrieve only the first field (by splitting the fields using the space character), which is the hash of our phrase.</p> <p>As standard input and standard error are redirected to /dev/null, we won't see the output from the echo command, however we can notice that the password for bandit23 is printed in the file <code>/tmp/hashed_phrase</code>.</p> <p>Thus, we know that by running the following command : <pre><code>cat /tmp/8ca319486bfbbc3663ea0fbe81326349\n</code></pre> (where <code>8ca319486bfbbc3663ea0fbe81326349</code> is the hash of \"I am user bandit23\"), we can retrieve the password for the bandit23 user.</p> Full Solution <ol> <li><code>cat /tmp/8ca319486bfbbc3663ea0fbe81326349</code> to retrieve the password for the next level</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit23/","title":"Bandit23-&gt;24","text":""},{"location":"bandit/docs/bandit23/#level-goal","title":"Level Goal","text":"<p>A program is running automatically at regular intervals from cron, the time-based job scheduler. Look in /etc/cron.d/  for the configuration and see what command is being executed.</p> <p>NOTE: This level requires you to create your own first shell-script. This is a very big step and you should be proud of yourself when you beat this level!</p> <p>NOTE 2: Keep in mind that your shell script is removed once executed, so you may want to keep a copy around\u2026</p>"},{"location":"bandit/docs/bandit23/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>chmod</li> <li>stat</li> <li>touch</li> <li>timeout</li> </ul>"},{"location":"bandit/docs/bandit23/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>File Permissions</li> <li>Filename Expansion</li> <li>Looping Constructs</li> <li>Conditional Constructs</li> <li>Shebang Unix</li> <li>Can a file that is executable be read ServerFault Discussion</li> <li>How does the #! shebang work ? StackOverflow Discussion</li> <li>Shell script working without shebang, why? StackOverflow Discussion</li> <li>Execute vs Read bit. How do directory permissions in Linux work UnixStackexchange Discussion</li> </ul>"},{"location":"bandit/docs/bandit23/#where-to-start","title":"Where to start?","text":"<p>The goal of this level, is to have you write your first shell script (if you didn't write one before). Even though the shell scripts we're going to write in this level are pretty simple, I think it is a very good occasion to learn more about File Permissions so that after beating this level you'll understand deeply what they mean and how to set them properly.</p> Info <p>On a more personal note, even though I did a lot of bash scripting before, and thus thought that this level would be a piece of cake, it took me 3 days to figure out the solution to that level. Not because I couldn't write a script but because I never cared that much about file permissions so you can trust me, I'll set you on the right track for thinking about file permissions in a Linux environment.</p> <p>For the script retrieval, as with the previous level, I'll let you see the level 21 and then come back when the script is in front of your eyes.</p> Part 1 : Script analysis <p>In this first part, we're going to analyse the script in order to know what it is about and how to use it to retrieve the password for the next level.</p> Hint <p>Using the useful commands and the helpful reading material, can you figure out what the script does?</p> Solution <p>We already know from the previous level that the script changes the directory to <code>/var/spool/bandit24/foo</code> as <code>bandit24</code> is the value contained in the <code>myname</code> variable.</p> <p>The script then executes as follows :</p> <ol> <li>for all the files and the hidden files in the directory, it executes a loop (see Filename Expansion for more explanations about how the patterns are matched).</li> <li>In this loop, if the filename is not '.' or '..', then it does the test that follows.</li> <li>The call to the stat command only prints the username of the owner of the file. So if the owner is bandit23 (which is us), it runs the following command.</li> <li>The call to the timeout utility runs the script for at most 60 seconds and then sends a SIGKILL signal to the script to ensure it stops.</li> <li>Regardless of whether the script was executed or not, the script is removed, which means that the directory ends up being totally empty at the end of the cronjob execution.</li> </ol> Part 2 : Creating a basic script <p>Now that we know what the program does, we understand that we just need to create a script and put it in the right folder (which is /var/spool/bandit24/foo) and if properly written it will give us the password for the bandit24 level.</p> Hint <p>Using the previous level, can you design a simple script to print bandit24 password in a way we can retrieve it? Recall that all output is redirected to /dev/null, which means you may have to create a file where bandit24 will be able to write the password to.</p> Solution <p>For this basic script, we'll copy the model of bandit22. This means that we'll write a simple script that prints the password to a custom file. Here is the script we'll use : <pre><code>#!/usr/bin/env bash\n\nfilename=\"$(echo Hello my fellow mates | md5sum | cut -d ' ' -f 1)\"\ncat /etc/bandit_pass/bandit24 &gt; /tmp/${filename}\n</code></pre> We're going to store this script in a file called <code>script</code> (but you can use any name you want) and copy this file to the proper location, which is <code>/var/spool/bandit24/foo</code>. We will then run a for loop to check for the script presence in this folder (in order to know whether or not the script has executed and to see if it has done what we want)</p> <ol> <li>First, we're going to go in a temporary directory (with <code>cd \"$(mktemp -d /tmp/hello_fellow_mates.XXXXXXXXXX)\"</code>) Don't worry about the funny name template, I just though it was funnier that just using tmp everytime</li> <li>Then we are going to write our script to a file called <code>script</code></li> <li>Then we are going to run the following commands : <pre><code>cp script /var/spool/bandit24/foo/script\necho -n Waiting for cronjob\nwhile stat /var/spool/bandit24/foo/script &gt;&amp; /dev/null ; do echo -n . ; sleep 1 ; done\necho -e '\\n'cronjob executed\n</code></pre> The last part allows us to monitor (using the <code>stat</code> command that returns true if it found the script at the specified location) the script and see when it is executed (thus meaning that we should expect an output).</li> </ol> Part 3 : Setting the proper file permissions <p>Once the cronjob has executed, when we try to run <code>cat /tmp/\"$(echo Hello my fellow mates | md5sum | cut -d ' ' -f 1)\"</code>, we see the following output :</p> <pre><code>bandit23@bandit:/tmp/hello_fellow_mates.1JNCwI8su9$ cat /tmp/$(echo Hello my fellow mates | md5sum | cut -d ' ' -f 1)\ncat: /tmp/af1eebe9db8a5242b192026716ddde8f: No such file or directory\nbandit23@bandit:/tmp/hello_fellow_mates.1JNCwI8su9$\n</code></pre> Bug <p>Wtf Shelltief, you told us that this script was working?!</p> <p>Well, bear with me because it is. The only thing we need is to give bandit24 the permission to execute it. Until now, it was not executing because bandit24 wasn't granted the rights to run the script, thus deleting it without even running it.</p> Hint <p>By reading the File Permissions section of the gnu coreutils documentation, can you figure out how to set the right file permissions for the script to actually execute?</p> Solution <p>Lets run a quick stat on our script file. We will run the following command : <pre><code>stat -c '%A Uid: (%u/%U)  Gid: (%g/%G)' script\n</code></pre> to print only the relevent information. Here is the output from that command : <pre><code>-rw-rw-r-- Uid: (11023/bandit23)  Gid: (11023/bandit23)\n</code></pre> This tells us no one is allowed to execute the script. As bandit24 is not in the group bandit 23 (see the group man page for more informations about it). We can deduce that bandit24 belongs in the others category.</p> <p>By running the following command : <pre><code>chmod o+x script\n</code></pre> We can allow the other users to execute the script, thus allowing bandit24 to execute the script. We can then run our precedent set of commands : <pre><code>cp script /var/spool/bandit24/foo/script\necho -n Waiting for cronjob\nwhile stat /var/spool/bandit24/foo/script &gt;&amp; /dev/null ; do echo -n . ; sleep 1 ; done\necho -e '\\n'cronjob executed\n</code></pre> And then, when we run <code>cat /tmp/\"$(echo Hello my fellow mates | md5sum | cut -d ' ' -f 1)\"</code>, we can see the password printed to stdout.</p> Full Solution <ol> <li><code>cd \"$(mktemp -d)\"</code> to change directory to a temporary directory</li> <li><code>echo -e \"#!/usr/bin/env bash\\ncat /etc/bandit_pass/bandit24 &gt; /tmp/\\\"$(echo Hello my fellow mates | md5sum | cut -d ' ' -f 1)\\\" &gt; script\"</code> to create the script that we'll use to print the password in our dedicated file.</li> <li><code>chmod o+x script</code> to give bandit24 permission to execute the script</li> <li><code>cat /tmp/\"$(echo Hello my fellow mates | md5sum | cut -d ' ' -f 1)\"</code> to retrieve the password</li> </ol> Bonus : Creating a file inside the directory <p>We learned how to create a file to store the password in, let's now go one step further and see whether or not we can figure out how to create a script that creates a file containing the password within our temporary directory.</p> Hint <p>Using what we did before and the Helpful Reading Material, can you figure out a way to write a script that will be able to create a file in our temporary directory? You will have to make another call to chmod to get all the file permissions right.</p> Solution <p>Here is our script : <pre><code>#!/usr/bin/env bash\n\ncat /etc/bandit_pass/bandit24 &gt; /tmp/hello_fellow_mates.1JNCwI8su9/bandit24_pass\n</code></pre></p> <p>Let's run a quick <code>stat</code>, but this time on our directory : <pre><code>bandit23@bandit:/tmp/hello_fellow_mates.1JNCwI8su9$ stat -c '%A Uid: (%u/%U)  Gid: (%g/%G)' .\ndrwx------ Uid: (11023/bandit23)  Gid: (11023/bandit23)\nbandit23@bandit:/tmp/hello_fellow_mates.1JNCwI8su9$\n</code></pre> Here we can see that others don't have any right to write to the directory nor to access its files. Let's call <code>chmod</code> on our directory to set the right permissions : <pre><code>chmod o+wx .\n</code></pre> Then, by putting our script back into the <code>/var/spool/bandit24/foo</code> directory, we will see the file <code>bandit24_pass</code> created after the cronjob execution.</p> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit24/","title":"Bandit24-&gt;25","text":""},{"location":"bandit/docs/bandit24/#level-goal","title":"Level Goal","text":"<p>A daemon is listening on port 30002 and will give you the password for bandit25 if given the password for bandit24 and a secret numeric 4-digit pincode. There is no way to retrieve the pincode except by going through all of the 10000 combinations, called brute-forcing. You do not need to create new connections each time</p>"},{"location":"bandit/docs/bandit24/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>nc</li> <li>printf</li> </ul>"},{"location":"bandit/docs/bandit24/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Brute force attack</li> <li>Brace Expansion</li> <li>Looping Constructs</li> </ul>"},{"location":"bandit/docs/bandit24/#where-to-start","title":"Where to start?","text":"<p>We already know that there is a daemon listening on port 30002 which listens for our password. The goal here is to find an efficient way to brute-force the password for the next level.</p> Part 1 : Getting to know the daemon <p>This part will be pretty short as we already have experience with daemons (see bandit14 for more explanations). We will simply connect and try to communicate with the daemon to see how we should speak with it.</p> Hint <p>By using the <code>nc</code> utility, can you figure out the format of the string you should send the daemon in order to craft your brute-force attack?</p> Solution <p>Using nc, we can speak with the daemon and run the following tests : <pre><code>bandit24@bandit:/tmp/abcdef.PtK5$ nc localhost 30002\nI am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space.\nbandit24_password 0000\nWrong! Please enter the correct pincode. Try again.\nbandit24_pasword 0001\nWrong! Please enter the correct pincode. Try again.\n^C\nbandit24@bandit:/tmp/abcdef.PtK5$ \n</code></pre> Using that information, we know the format of the string we're supposed to send to the daemon to try to bruteforce the password. Let's now try and use this knowledge to craft our brute-force attack.</p> Part 2 : Crafting the attack <p>Now that we know how to communicate with the server and that we noticed that indeed, we don't have to open a new connection for each message, let's try to generate all the password/pincode combinations for our brute-force attack.</p> Hint <p>Using the Brace Expansion, the Looping Constructs and the printf sections of the gnu bash manual, can you figure out a way to generate all the combinations for our attack?</p> Solution <p>You'll be able to find a lot of solutions following the same pattern all over the internet. Let's try to do something a bit different.</p> <p>We are going to use a <code>for</code> loop, but not the one that depends on a pattern, the one that depends on an arithmetic expression.</p> <p>Here is what our loop is going to be : <pre><code>for (( i=0 ; i &lt; 10000 ; ++i )) ; do printf \"%s %04d\\n\" \"bandit24_pass\" \"$i\" ; done\n</code></pre></p> <p>Here is a detail of what our loop does :</p> <ol> <li>For all the integers between 0 and 9999 it does the following :</li> <li>It prints the string bandit24_pass alongside the value of the integer (padded with zeros on the left to fit a field width of 4 characters)</li> </ol> Part 3 : Launching the attack and retrieving the password <p>Now that we know what our for loop looks like, you might want to know why we used this construct instead of the first form. Let's not wonder about that for now and instead launch the attack.</p> Hint <p>Using our newly constructed for loop, can you figure out a way to use nc to retrieve the password?</p> Solution <p>Here is how we are going to use our for loop to retrieve the password. <pre><code>for (( i=0 ; i &lt; 10000 ; ++i )) ; do printf \"%s %04d\\n\" \"bandit24_pass\" \"$i\" ; done | nc -w 10 localhost 30002\n</code></pre> This loop will test all the 10000 strings against the server pin and will be enough to retrieve the password.</p> Info <p>The <code>-w</code> option of nc allows to specify a timeout in case the connection becomes idle. If the timeout is reached, the connection will be closed.</p> Part 4 : Let me think please <p>If this hasn't been patched yet, you might notice that the server blocks indefinitely after a given number of attempts. The goal of this last part is to ensure that the server won't block and that we'll be able to test all the connections.</p> Hint <p>Using our command from the last part, would you be able to add a simple check to ensure that the server doesn't test all the attempts at the same time but waits a bit before sending each chunk of tests.</p> Solution <p>Here is the updated command : <pre><code>for (( i=0 ; i &lt; 10000 ; ++i )) ; do if (( $i%500 == 0 )) ; then sleep 1 ; fi ; printf \"%s %04d\\n\" \"bandit24_pass\" \"$i\" ; done | nc -w 10 localhost 30002\n</code></pre> The <code>if</code> check ensure that the server gets time to process the input, ensuring that it won't block after a given amount of requests.</p> Full Solution <ol> <li><code>for (( i=0 ; i &lt; 10000 ; ++i )) ; do if (( $i%500 == 0 )) ; then sleep 1 ; fi ; printf \"%s %04d\\n\" \"bandit24_pass\" \"$i\" ; done | nc -w 10 localhost 30002</code> this command will test the password and all of the 10000 pin combinations agains the server pin and prints the password for the next level once the right pin has been entered.</li> </ol> Warning <p>Do not forget to replace bandit24_pass with the actual password for the bandit24 user.</p> <p>you can now jump to the next level</p>"},{"location":"bandit/docs/bandit25/","title":"Bandit25-&gt;26","text":""},{"location":"bandit/docs/bandit25/#level-goal","title":"Level Goal","text":"<p>Logging in to bandit26 from bandit25 should be fairly easy\u2026 The shell for user bandit26 is not /bin/bash, but something else.  Find out what it is, how it works and how to break out of it.</p>"},{"location":"bandit/docs/bandit25/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>vi</li> <li>more</li> <li>cat</li> </ul>"},{"location":"bandit/docs/bandit25/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Vim Documentation Options</li> <li>passwd(5) man page</li> <li>Does ssh run commands rather than itself in a login shell Unix StackExchange  Discussion</li> <li>Vim various commands</li> </ul>"},{"location":"bandit/docs/bandit25/#where-to-start","title":"Where to start?","text":"<p>By listing the contents of the directory, we can see that there is a private key that we should use to log in as the user bandit26, this means that this isn't where the true challenge of this level is. Let's try and analyse the level following the guidelines at the beginning.</p> Part 1 : Retrieving bandit26 shell <p>The first thing we need to do is to retrieve bandit26 shell, as we know that this shell is not /bin/bash.</p> Hint <p>Using the passwd(5) man page, can you figure out a way to retrieve the shell that bandit26 gets when it logs in and to view its contents?</p> Solution <p>Using the <code>passwd(5)</code> man page, we know that the informations for the bandit 26 user are stored in the <code>/etc/passwd</code> file. This file is readable by everyone so we can print its content and <code>grep</code> only the lines containing bandit26. Here is the command we'll run, alongside its output : <pre><code>bandit25@bandit:~$ cat /etc/passwd | grep bandit26\nbandit26:x:11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtext\nbandit25@bandit:~$\n</code></pre> We know from the <code>passwd(5)</code> man page that the last field is the bandit26 user's shell : <code>/usr/bin/showtext</code>.</p> <p>Let's print the contents of this file : <pre><code>#!/bin/sh\n\nexport TERM=linux\n\nexec more ~/text.txt\nexit 0\n</code></pre> We see here that the script sets one variable <code>TERM</code> and then runs the <code>more</code> utility.</p> <p>One thing we can already notice is that the <code>showtext</code> executable doesn't take any argument, so we won't be able to ssh our way into bandit26 account running a command like we did in level18 (see how ssh commands are run for more explanations). We'll have to find another way to get in.</p> Part 2 : Let's scroll that thing <p>When we first ssh our way into bandit26, we see that the <code>showtext</code> executable is ran. It prints the text bandit26 in ASCII art and then exits.</p> <p>We already know that the <code>showtext</code> executable uses more, the real challenge here is to take advantage of the <code>more</code> capabilities to run commands. To do so, we need to make it scrollable so that it shows its command prompt.</p> Hint <p>By doing some tests with files on your own computer, can you figure out when more is scrollable and where it isn't? Doing so, could you make it scrollable when logging in into bandit26 and find which command to run to get a text editor?</p> Solution <p>Although it is not very intuitive, you might have noticed that when the window size is smaller than the number of text lines, <code>more</code> becomes scrollable. We're going to use this capability of the <code>more</code> utility to break out of it. Let's minimize our window to less than 6 lines and then ssh into bandit26.</p> Info <p>There might be a more elegant solution through the use of a terminal multiplexer like tmux but the idea will basically be the same. I'll provide a solution using <code>tmux(1)</code> once I learn to use it.</p> <p>We can now enter commands (see more man page for the full list). We are going to use the <code>v</code> command in order to open the vim editor.</p> <p>We can now bring our window size back to normal.</p> Part 3 : Byebye showtext <p>Now that we got inside <code>vim</code>, we have to get rid of this nice yet useless shell and get a real one.</p> Hint <p>Using the various remaining commands file of the vim help manual, can you figure out a way to get a shell while in the vim editor?</p> Solution <p>The command <code>:shell</code> is the one we need. Remember that you need to press <code>&lt;ESC&gt;</code> first to get into normal mode However, when running it for the first time we can see that nothing seems to happen. The truth is that something really happened in front of our eyes. The shell of the user bandit26 was launched and then exited as it is the <code>showtext</code> executable.</p> Example <p>To convince yourself that it really happened, you can minimize the window to less than 6 lines before running the <code>:shell</code> command</p> <p>We now need to change the default shell for user bandit26 in order to finally get out of that showtext hell.</p> Part 4 : Getting bash back <p>We now know that we can run a shell, let's try to change the default shell to <code>/usr/bin/bash</code> in order to actually run a shell.</p> Hint <p>Using the Vim Documentation Options, can you figure out how to view, then change, the shell we're using when running the <code>:shell</code> command?</p> Solution <p>The command we're looking for is <code>:set</code> which allows us to view/change settings for the options we specify.</p> <p>By running <code>:set shell</code> we can view the shell we're using (which in our case outputs <code>/usr/bin/showtext</code>).</p> <p>To change the shell, we just have to run <code>:set shell=/usr/bin/bash</code>, we can then run <code>:shell</code> and get a shell for the user bandit26.</p> Full Solution <ol> <li>Minimize the window and ssh into bandit26 account to make the <code>more</code> utility scrollable.</li> <li>Enter the <code>v</code> command to open the ViM text editor</li> <li><code>:set shell=/usr/bin/bash</code> in order to set the default shell to a real shell</li> <li><code>:shell</code> to open the bash shell for the user bandit26</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit26/","title":"Bandit26-&gt;27","text":""},{"location":"bandit/docs/bandit26/#level-goal","title":"Level Goal","text":"<p>Good job getting a shell! Now hurry and grab the password for bandit27!</p>"},{"location":"bandit/docs/bandit26/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":""},{"location":"bandit/docs/bandit26/#helpful-reading-material","title":"Helpful Reading Material","text":""},{"location":"bandit/docs/bandit26/#where-to-start","title":"Where to start?","text":"<p>This level is the exact same as the level 19. If you need any information, go check this level.</p> Full Solution <ol> <li><code>./bandit27-do cat /etc/bandit_pass/bandit27</code> to print the bandit27 password to standard output.</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit27/","title":"Bandit27-&gt;28","text":""},{"location":"bandit/docs/bandit27/#level-goal","title":"Level Goal","text":"<p>There is a git repository at ssh://bandit27-git@localhost/home/bandit27-git/repo via the port 2220.  The password for the user bandit27-git is the same as for the user bandit27.</p> <p>Clone the repository and find the password for the next level.</p>"},{"location":"bandit/docs/bandit27/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>git</li> <li>git-clone</li> <li>ls</li> <li>cat</li> </ul>"},{"location":"bandit/docs/bandit27/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Git Wikipedia Page</li> <li>Git user manual</li> <li>Git Tutorial Part 1</li> </ul>"},{"location":"bandit/docs/bandit27/#where-to-start","title":"Where to start?","text":"<p>Here we enter a series of levels that are aimed to teach us the git basics. Let's dive right in and solve the first level</p> Part 1 : Getting the repository <p>Our first challenge in our quest to master Git is to unterstand how to get a copy of a guide repository (or clone).</p> Hint <p>By doing the first part of the gittutorial and reading the git-clone man page, can you figure out a way to retrieve the repository located at <code>ssh://bandit27-git@localhost/home/bandit27-git/repo</code> ?</p> Info <p>You might need to create a temporary directory</p> Solution <p>Lets first change directory to a temporary directory with <code>cd \"$(mktemp -d /tmp/bandit27git.XXXXX)\"</code>, then we can run the following command : <pre><code>git clone ssh://bandit27-git@localhost:2220/home/bandit27-git/repo\n</code></pre> Remember that we have to specify the port as we're not connecting using the port 22 (ssh default's port) but the port 2220.</p> <p>We can then enter the password for bandit27-git (which is the password for bandit27) and we see the repository <code>repo</code> appear in our temporary directory.</p> <p>We can now try to retrieve the password.</p> Part 2 : Retrieving the password <p>For this level, the password retrieval is pretty straightforward.</p> Hint <p>Try listing the contents of the directory.</p> Solution <p>By running <code>cat README.md</code> we can retrieve the password for the next level.</p> Full Solution <ol> <li><code>cd \"$(mktemp -d /tmp/bandit27git.XXXXXX)\"</code> to change to a temporary directory</li> <li><code>git clone ssh://bandit27-git@localhost:2220/home/bandit27-git/repo</code> to clone the repository into our directory</li> <li><code>cat README</code> to retrieve the password</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit28/","title":"Bandit28-&gt;29","text":""},{"location":"bandit/docs/bandit28/#level-goal","title":"Level Goal","text":"<p>There is a git repository at ssh://bandit28-git@localhost/home/bandit28-git/repo via the port 2220.  The password for the user bandit28-git is the same as for the user bandit28.</p> <p>Clone the repository and find the password for the next level.</p>"},{"location":"bandit/docs/bandit28/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>git-log</li> <li>git-show</li> </ul>"},{"location":"bandit/docs/bandit28/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Git Everyday Commands A useful minimum set of commands for Everyday Git</li> </ul>"},{"location":"bandit/docs/bandit28/#where-to-start","title":"Where to start?","text":"<p>For more informations about how to clone the repository, see the previous level.</p> <p>From now on, I'll assume that you already retrieved the git repository in your temporary directory.</p> Part 1 : Viewing the history <p>In this level, when we <code>cat</code> the README.md file in the directory, we have a series of x's instead of the password like in the previous level. Of course, this series of x's isn't the password so we'll need to find a way to retrieve it.</p> Hint <p>As git stores the whole history of the file modifications, looking at the git-log man page, can you figure out a way to view the history of the git repository?</p> Solution <p>By running the <code>git-log</code> command, we can see that the commit history talks about missing data that has been added and the commit we're on talks about a memory leak. Our next goal will be to check for differences between the <code>HEAD</code> which is the point we're on in the history (usually after the last commit) and the commit that talks about missing data.</p> Part 2 : Retrieving the password <p>Now that we know where the information we'd like to retrieve might be, we need for a way to check if this information is actually there.</p> Hint <p>Looking at the git-show man page, can you figure out a way to view the differences between the README at the current commit and the README at the previous commit?</p> Solution <p>Using the <code>git-show</code> command, we can provide the hash of the commit we want to view</p> Info <p>We don't need to provide the full hash and the 5 first characters are usually enough</p> <p>Here, we have that the commit <code>f08b9</code> is mentionning an info leak. Let's try to see what are the differences between this commit and the commit we're looking at. Let's run the following command in our terminal : <pre><code>git show f08b9\n</code></pre> This will print the last change in the <code>README.md</code> file, thus printing the password string.</p> Full Solution <ol> <li><code>git log</code> to view all the commit history.</li> <li><code>git show f08b9</code> to view the difference with the previous commit.</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit29/","title":"Bandit29-&gt;30","text":""},{"location":"bandit/docs/bandit29/#level-goal","title":"Level Goal","text":"<p>There is a git repository at ssh://bandit29-git@localhost/home/bandit29-git/repo via the port 2220.  The password for the user bandit29-git is the same as for the user bandit29.</p> <p>Clone the repository and find the password for the next level.</p>"},{"location":"bandit/docs/bandit29/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>git-branch</li> <li>git-diff</li> </ul>"},{"location":"bandit/docs/bandit29/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Branches in a nutshell See bandit27 and bandit28 for more helpful reading material</li> </ul>"},{"location":"bandit/docs/bandit29/#where-to-start","title":"Where to start?","text":"<p>Once again, I'll assume that you already cloned the repository (see bandit27 for more informations).</p> Part 1 : Viewing all the branches <p>When we try to view the log and to show the differences in the repository, we don't get any relevant information.</p> <p>Another great capability of git is the ability to <code>branch</code>. A branch is a line of development which is totally independent from all the others from the point when it has been created.</p> Hint <p>By looking at the git-branch man page, can you figure out a way to list all the branches in the repository?</p> Solution <p>We want to list all the branches of the repository. Let's run the following command : <pre><code>git branch -a\n</code></pre> This will list all the local branches (which is only master at the moment) and all the remote tracking branches. The following command outputs 3 branches : <code>dev</code>, <code>master</code> and <code>sploits-dev</code>. Let's now see if we can retrieve the password in one of these two other branches.</p> Part 2 : Viewing the differences between the branches <p>Now that we know that there are multiple branches, we'll try to view the differences between the README.md file and the files on the other branches</p> Hint <p>Looking at the git-diff man page, can you figure out a way to view the differences between the master branch and the other branches?</p> Solution <p>Let's try and run the following command : <pre><code>git diff remotes/origin/dev\n</code></pre></p> Info <p>We need to use remotes/origin/dev because the dev branch is not tracked locally. To track the remotes/origin/dev locally you'd have to run <code>git checkout dev</code> first.</p> <p>When running the following command, we can see that the password is on the <code>dev</code> branch and use it to connect to the next level.</p> Full Solution <ol> <li><code>git branch -a</code> to view all the branches in the repository</li> <li><code>git diff remotes/origin/dev</code> to view the changes between the <code>dev</code> branch and the master branch</li> </ol> Tip <p>One key takeaway of this level may be the Git mantra : branch early and branch often. A branch is cheap, easy to make experiments on and to delete when not needed anymore</p> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit3/","title":"Bandit3-&gt;4","text":""},{"location":"bandit/docs/bandit3/#level-goal","title":"Level Goal","text":"<p>The password for the next level is stored in a hidden file in the inhere directory.</p>"},{"location":"bandit/docs/bandit3/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>cd</li> <li>ls</li> <li>cat</li> </ul>"},{"location":"bandit/docs/bandit3/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Hidden file and hidden directory</li> <li>What are directories, if everything on Linux is a file?</li> <li>inode(7) man page</li> </ul>"},{"location":"bandit/docs/bandit3/#where-to-start","title":"Where to start?","text":"<p>In this challenge, we're now introduced to 2 new notions : directories and hidden files. The reading material gives valuable information and helps us  understand better what actually is a directory and what are hidden files. One key takeaway is that hidden files are not safer that regular files, they are  just not listed by default by listing utilities. However, the information that they are not listed by default already gives us two hints :</p> <ol> <li>The file is there</li> <li>We can access it</li> </ol> <p>Now, let's dive into how we are going to actually view and access the file in this hidden directory.</p>"},{"location":"bandit/docs/bandit3/#lets-move-i-want-to-be-close-to-the-file-im-looking-for","title":"Let's move, I want to be close to the file I'm looking for","text":"Part 1 : the cd builtin <p>Let's now meet a new friend, the <code>cd</code> builtin. We will need to use  this builtin to navigate to the directory named inhere.</p> Hint <p><code>man cd</code> doesn't work here. Indeed, the <code>cd</code> builtin is part of the shell you're using (I'll assume you're using bash). </p> <p>However, you can view the SHELL BUILTIN COMMANDS section of the gnu bash manual.</p> Solution <p>To effectively change directory to the inhere directory, we need to run the command <code>cd inhere</code>.</p> Part 2 : listing hidden files <p>Now that we are in the inhere directory, if we run the <code>ls</code> command, this is the output we get :</p> <pre><code>bandit3@bandit:~/inhere$ ls\nbandit3@bandit:~/inhere$\n</code></pre> <p>However, we know that there is a hidden file in this directory, we need to find a way to retrive that file.</p> Hint <p>Look at the DESCRIPTION section of ls.  The option you're looking for should be near the top</p> Solution <p>The <code>-a</code> or <code>--all</code> is the option you're looking for. It allows to not ignore the entries starting with a <code>.</code>. This is the output we get after listing all of our directory contents : </p> <pre><code>bandit3@bandit:~/inhere$ ls --all\n.  ..  .hidden\nbandit3@bandit:~/inhere$\n</code></pre> <p>Now that we know that the file we're are looking for, we can print its content with <code>cat .hidden</code></p> Full Solution <ol> <li><code>cd inhere</code> to change directory to the inhere directory</li> <li><code>ls --all</code> to print all the contents of the inhere directory</li> <li><code>cat .hidden</code> to print the hidden file</li> </ol>"},{"location":"bandit/docs/bandit3/#why-move-i-can-do-everything-from-my-home-directory","title":"Why move ? I can do everything from my home directory","text":"<p>The idea is basically the same than if we wanted to move, with a slight variation.</p> Part 1 : listing the directory contents <p>Up until now, we used the <code>ls</code> utility with options but without any argument. We need to find a way to specify a directory to the <code>ls</code> command.</p> Hint <p>Once again, we'll look in the ls  man page, but this time we need to have a look in the SYNOPSYS section.</p> Solution <p>The command <code>ls --all inhere</code> it the command we're looking for. this command will allow us to list the contents of the inhere directory,  without moving nor ignoring the hidden files. Running it gives us the following output :</p> <pre><code>bandit3@bandit:~$ ls --all inhere\n.  ..  .hidden\nbandit3@bandit:~$\n</code></pre> Part 2 : printing the hidden file <p>Now that we now that the hidden file in the inhere directory is called <code>.hidden</code>, we can run <code>cat</code> and give it the relative path  to the <code>.hidden</code> file as an argument : <code>cat inhere/.hidden</code>. This will dump the password string to stdout</p> Full Solution <ol> <li><code>ls --all inhere</code> to list the contents of the inhere directory</li> <li><code>cat inhere/.hidden</code> to print the contents of the <code>.hidden</code> file</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit30/","title":"Bandit30-&gt;31","text":""},{"location":"bandit/docs/bandit30/#level-goal","title":"Level Goal","text":"<p>There is a git repository at ssh://bandit30-git@localhost/home/bandit30-git/repo via the port 2220.  The password for the user bandit30-git is the same as for the user bandit30.</p> <p>Clone the repository and find the password for the next level.</p>"},{"location":"bandit/docs/bandit30/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>git-tag</li> <li>git-show</li> </ul>"},{"location":"bandit/docs/bandit30/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Tagging</li> </ul>"},{"location":"bandit/docs/bandit30/#where-to-start","title":"Where to start?","text":"<p>Once again, if you need information about retrieving the repository, go check bandit27 level.</p> <p>Here, we can notice that nothing we did precedently works. As we had to do with the other levels, we have to learn another git capability and use it to retrieve the password.</p> Part 1 : Viewing the points of interest in the history <p>One capability of git is to tag some commits as important, let's see if we can use it to our advantage and retrieve the password.</p> Hint <p>Using the git-tag command, can you figure out how to view all the tags of the git repository?</p> Solution <p>Let's run the following command : <pre><code>git tag\n</code></pre> This allows us to list all the tags within the git repository. This command outputs a <code>secret</code> tag which seems to be the door that separates us from our password.</p> Part 2 : Retrieving the information <p>Now that we got our tag, we have to retrieve the information that's hidden within it.</p> Hint <p>Using again the git-show man page, can you find a way to retrieve the informations within the <code>secret</code> tag?</p> Solution <p>Let's run the following command : <pre><code>git show secret\n</code></pre> This command lets us view the informations that were added during the tag creation. Of course they include this level password, thus allowing us to jump to the next level.</p> Full Solution <ol> <li><code>git tag</code> to list all the tags in the repository.</li> <li><code>git show secret</code> to view the informations within the secret tag and retrieve our password.</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit31/","title":"Bandit31-&gt;32","text":""},{"location":"bandit/docs/bandit31/#level-goal","title":"Level Goal","text":"<p>There is a git repository at ssh://bandit31-git@localhost/home/bandit31-git/repo via the port 2220.  The password for the user bandit31-git is the same as for the user bandit31.</p> <p>Clone the repository and find the password for the next level.</p>"},{"location":"bandit/docs/bandit31/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>cat</li> <li>git-add</li> <li>git-status</li> <li>git-commit</li> <li>git-push</li> </ul>"},{"location":"bandit/docs/bandit31/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Recording Changes to the Repository</li> <li>Gitignore Documentation</li> </ul>"},{"location":"bandit/docs/bandit31/#where-to-start","title":"Where to start?","text":"<p>When we <code>cat</code> the README.md file, we see that it gives us a set of instructions. We have to create a <code>key.txt</code> file  and \"push\" it to our remote repository.</p> Part 1 : Stagging the key.txt file <p>We need to create a file called <code>key.txt</code> with the contents 'May I come in?'. The real challenge here will be to stage the <code>key.txt</code> file for commit.</p> Hint <p>Using the git-add man page and the Gitignore Documentation, can you figure out a way to stage the <code>key.txt</code> file?</p> Solution <p>When we run <code>git add key.txt</code>, we get the information that the <code>key.txt</code> file has been marked as ignored by git (you can <code>cat</code> the <code>.gitignore</code> file in order to understand why). Thus running the following command : <pre><code>git add -f key.txt\n</code></pre> we can tell git to add the key.txt file even if git has been told to ignore it.</p> Part 2 : Pushing the key.txt file to the repository <p>Now that we've added the key.txt file to the stagging area, we need to push the file to the repository to validate the challenge.</p> Hint <p>Using the git-commit and the git-push man pages, can you figure out how to push the file to the repository?</p> Solution <p>Each commit must have a, preferably explicit, commit message. Then after taking our snapshot of the state of the repository, we can then push our set of snapshots to the remote repository. We can use the <code>-m</code> option of <code>git commit</code> to specify the message on the command line.</p> <p>Here are our two commands : <pre><code>git commit -m \"explicit commit message\"\ngit push\n</code></pre> As we followed all the instructions, we get the password for the next level in the response.</p> Full Solution <ol> <li><code>echo \"May I come in?\" &gt; key.txt</code> to create the <code>key.txt</code> file.</li> <li><code>git add -f key.txt</code> to forcefully add the <code>key.txt</code> file to the stagging area.</li> <li><code>git commit -m \"explicit message\"</code> to commit the changes</li> <li><code>git push</code> to push our changes to the remote repository</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit32/","title":"Bandit32-&gt;33","text":""},{"location":"bandit/docs/bandit32/#level-goal","title":"Level Goal","text":"<p>After all this git stuff its time for another escape. Good luck!</p>"},{"location":"bandit/docs/bandit32/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>bash</li> <li>man</li> </ul>"},{"location":"bandit/docs/bandit32/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Man Page</li> <li>Special Parameters</li> </ul>"},{"location":"bandit/docs/bandit32/#where-to-start","title":"Where to start?","text":"Info <p>To be honest I don't have the same experience with the uppercase shell than the one I had with the showtext executable. I hated showtext because it litteraly did nothing and wasn't acknowledging my inputs when the uppercase shell seems to be yelling and trolling me and I find that kinda funny. Let's now dive into the challenge.</p> <p>The problem seems pretty obvious to spot, everything we type is converted to uppercase, so our first goal is to understand the shell we've been given.</p> Part 1 : Getting to know the uppercase shell <p>We'll start by trying to input some commands and get to know what is the uppercase shell really doing. Then, using that insight, we will try to figure out what we can actually do with that shell.</p> Hint <p>By testing and trying to run some commands, can you describe the effects of the uppercase shell and can you see what type of input will be unaffected by the effects of that shell?</p> Solution <p>Now that we made some tests with the uppercase shell, we can notice that it converts all of our input to uppercase before feeding it to an actual shell. From that, we can deduce that the only input that will stay unaffected by the effect of this shell will be shell variables (as they are usually already uppercase).</p> Part 2 : Getting an actual shell <p>Knowing that shell variables are unaffected by the uppercase shell, we'll need to use that feature to get an actual shell.</p> Hint <p>Using the special parameters section of the gnu bash manual, can you figure out which variable to use to get a shell?</p> Solution <p>As the uppercase shell actually converts our input to uppercase before feeding it to an actual shell, the <code>$0</code> variable contains the name of the shell it invokes. Thus, by running the following command : <pre><code>$0\n</code></pre> We can then get an actual shell and use it to <code>cat</code> the bandit33 password.</p> Full Solution <ol> <li><code>$0</code> to get an actual shell (which will in fact be sh)</li> <li><code>cat /etc/bandit_pass/bandit33</code> to get the password for the next level.</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit33/","title":"Thank you Overthewire","text":"<p>Congratulations on solving the last level of this game!</p> <p>At this moment, there are no more levels to play in this game. However, we are constantly working on new levels and will most likely expand this game with more levels soon. Keep an eye out for an announcement on our usual communication channels! In the meantime, you could play some of our other wargames.</p> <p>If you have an idea for an awesome new level, please let us know!</p>"},{"location":"bandit/docs/bandit4/","title":"Bandit4-&gt;5","text":""},{"location":"bandit/docs/bandit4/#level-goal","title":"Level Goal","text":"<p>The password for the next level is stored in the only human-readable file in the inhere directory. Tip: if your terminal is messed up, try the \u201creset\u201d command.</p>"},{"location":"bandit/docs/bandit4/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>find</li> <li>cat</li> <li>file</li> </ul>"},{"location":"bandit/docs/bandit4/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Regular File</li> <li>Human Readable File</li> <li>GNU findutils documentation</li> </ul>"},{"location":"bandit/docs/bandit4/#where-to-start","title":"Where to start?","text":"<p>As there isn't a lot of helpful reading material (because the material is already very complete), we must start by opening  the find(1) documentation </p> <p>Now that we got an idea of what the find utility does we need to know exactly what characteristics the file we are looking for has. - it is human-readable. - it is a file</p> <p>We need to find a way to only for human readable files in a given directory</p> Part 1 : Finding directory files <p>During all this level, we are only going to use the <code>find(1)</code> utility. In fact, our solution to this level will consist in one unique  call to the <code>find(1)</code> utility. First things first, we need to know how to run the <code>find</code> command to list the directory files</p> Hint <p>Look at the starting points  section of the <code>find(1)</code> man page.</p> Solution <p>When looking in the starting points section of the <code>find(1)</code> man page, we see an optional argument named starting-point. This argument  allows the user to specify a starting directory when running the <code>find</code> utility. By default, the starting point is <code>.</code> which is the  current directory. So, running <code>find inhere</code> allows us to list the contents of the inhere directory</p> Part 2 : Listing only the files <p>Before delving deeper into the <code>find(1)</code> man page to know how we can use <code>find</code> to retrieve the only human-readable file in the inhere directory  let's take a closer look at the output we got from running <code>find</code> alone : <pre><code>bandit4@bandit:~$ find\n.\n./inhere\n./inhere/-file01\n./inhere/-file02\n./inhere/-file08\n./inhere/-file06\n./inhere/-file00\n./inhere/-file04\n./inhere/-file05\n./inhere/-file07\n./inhere/-file03\n./inhere/-file09\n./.profile\n./.bashrc\n./.bash_logout\nbandit4@bandit:~$\n</code></pre></p> <p>From that output, we can notice that find lists all the file in the directories and subdirectories, without ignoring hidden files by default. We can notice that it lists all the files and directories contained in the starting point, along with the starting point.</p> <p>Let's now try to list only the regular files within the inhere directory</p> Hint <p>By looking at the section 2 of the gnu findutils documentation  can you retrieve a test that tests for regular files?</p> Solution <p>The option we're looking for is <code>-type</code>, which allows us to test for the type of file we're looking for. We'll give the <code>-type</code> option the <code>f</code> argument  to only look for regular files. The command we're looking for is <code>find inhere -type f</code>.</p> Part 3 : Finding the only human readable file <p>Here is the output from the command <code>find inhere -type f</code> :  <pre><code>bandit4@bandit:~$ find inhere/ -type f\ninhere/-file01\ninhere/-file02\ninhere/-file08\ninhere/-file06\ninhere/-file00\ninhere/-file04\ninhere/-file05\ninhere/-file07\ninhere/-file03\ninhere/-file09\nbandit4@bandit:~$\n</code></pre></p> <p>We could try to manually run <code>cat</code> on each file but besides being an ugly as hell solution, it presents a  security risk.  Thankfully, there is a solution which stands in the <code>file(1)</code> utility We now need to find in the <code>file(1)</code> man page how to find the only human readable file within the inhere directory.</p> Hint <p>Look into the file(1) and the section 3 of the gnu  findutils documentation, see if there is an ACTION in the <code>find(1)</code> page that could let you execute the <code>file</code> command on the file you retrieved</p> Solution <p>The ACTION we're looking for is <code>-execdir</code>. We will use the form <code>-execdir command ;</code> as it is safer than the <code>-exec command ;</code>  form (see security considerations.  As the <code>;</code> is a metacharacter, we will need to escape it with a <code>\\</code> to pass it to the <code>find</code> command.  For the same reason, we'll have to enclose the brackets <code>{}</code> within simple or double quotes</p> <p>The command we're looking for is : <code>find inhere -type f -execdir file '{}' \\;</code> Here is an output you could get by running this command :  <pre><code>bandit4@bandit:~$ find inhere/ -type f -execdir file \"{}\" \\;\n./-file01: data\n./-file02: data\n./-file08: data\n./-file06: data\n./-file00: data\n./-file04: data\n./-file05: data\n./-file07: ASCII text\n./-file03: data\n./-file09: data\nbandit4@bandit:~$\n</code></pre> We can now run the command <code>cat inhere/-file07</code> to get the password string</p> Full Solution <ol> <li><code>find inhere/ -type f -execdir file \"{}\" \\;</code> to find all the regular files in the inhere directory and run the <code>file</code> utility on them</li> <li><code>cat inhere/-file07</code> to print the contents of the retrieved file</li> </ol> Bonus : One-liner command <p>Useful commands:</p> <ul> <li>bash (or any shell)</li> <li>find</li> <li>file</li> <li>grep</li> <li>cat</li> </ul> Hint <p>To get you started, if you want to find (no pun intended) by yourself, here are a few informations to  get you on the right track.</p> <p>Here are the <code>find</code> options we'll use to achieve our goal : - type - execdir (x2) - quit (optionnal)</p> Solution <p>The command is the following : <pre><code>find inhere/ -type f -execdir bash -c 'file {} | grep text &gt; /dev/null' \\; -execdir cat '{}' \\; -quit\n</code></pre> Here is a step-by-step overview of the command :</p> <ol> <li>The first execdir calls execute the command <code>file {} | grep text &gt; /dev/null</code> on each retrieved file in the inhere directory. </li> </ol> <p>The redirection to <code>/dev/null</code> is to ensure that nothing gets printed on stdout, but the important thing here is actually the  exit status of the <code>grep command</code>. See bash invocation for informations about the <code>-c</code> option.</p> <ol> <li>The second execdir calls cat on the only human-readable file in the inhere directory</li> <li>The quit option allows us to stop the <code>find</code> utility once we found what we're looking for. To understand what it does, you can  replace <code>grep</code> by <code>grep -v</code> in the previous command</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit5/","title":"Bandit5-&gt;6","text":""},{"location":"bandit/docs/bandit5/#level-goal","title":"Level Goal","text":"<p>The password for the next level is stored in a file somewhere under the inhere directory and has all of the following properties:</p> <ul> <li>human-readable</li> <li>1033 bytes in size</li> <li>not executable</li> </ul>"},{"location":"bandit/docs/bandit5/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>file</li> <li>find</li> <li>cat</li> </ul>"},{"location":"bandit/docs/bandit5/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>What does the execute permission do?</li> </ul>"},{"location":"bandit/docs/bandit5/#where-to-start","title":"Where to start?","text":"<p>The solution is very similar to the one of the previous level so check that one for a more in-depth explanation.  For this level, I will give less explanations and only add complements to teach you about where to find the relevant information.  Without further ado, let's dive right into the solution.</p>"},{"location":"bandit/docs/bandit5/#walkthrough","title":"Walkthrough","text":"<p>The goal of this exercise is to add options to the <code>find</code> command, so that the file we're retrieving meets all the requirements. We'll try to find the options one after the other into the find(1) documentation.</p> Option 1 : File Size <p>The first option we're looking for is an option that allows us to check for the file size. Let's look in the <code>find(1)</code> man page to see if we can find the option we need.</p> Hint <p>Try to look in the section 2 of the gnu findutils documentation.</p> Solution <p>The option we're looking for is described there. It is the <code>size</code> option.  We are going to invoke it like this : <code>-size 1033c</code>.</p> Option 2 : Not Executable <p>The second option we're looking for is an option that allows us to check for the executable permission on the file we encounter. Let's look once again into the <code>find(1)</code> man page (or the gnu findutils documentation) to find what we need.</p> Hint <p>This time, we still need to look at the section 2 of the gnu findutils documentation.  However, we need to look into two different subsections of this section 2 to complete our option.</p> Solution <p>The option we're looking for is described there. It is the <code>executable</code> option.  However, we need our file to not be executable, so we can see in this section  that to negate this condition we can use the <code>-not</code> operator. We are going to invoke our option like this : <code>-not -executable</code>.</p> Building the command <p>After getting our two options, the rest of the command is exactly the same as with the previous exercise. Here is our command :  <pre><code>find inhere -type f -size 1033c -not -executable -execdir file '{}' \\; -print\n</code></pre></p> <p>We need to print the file after because due to using the execdir option instead of the exec option (see the security considerations)</p> Security concerns : One-liner from previous exercise <p>In the previous level I gave you a one-liner to solve the level</p> <pre><code>find inhere/ -type f -execdir bash -c 'file {} | grep text &gt; /dev/null' \\; -execdir cat '{}' \\; -quit\n</code></pre> <p>Although this command gives the right answer, it presents a security concern.  Indeed, if an attacker puts a special filename in your directory, it could lead to the deletion of all of your data. Let's see a safe example right now. Try running the following script and understanding its output (you can copy and paste the script into you terminal window): </p> <pre><code>clear #This is to keep only the script outputs in case you copy-paste it to your terminal window\nmkdir -p /tmp/testrm\ncd \"$(mktemp -d)\" &amp;&amp; echo \"Step 1 - Now in temporary directory\" || kill -INT $$\necho \"Step 2 - creation of the /tmp/testrm directory, that will be useful to bring out our security concern\"\nif ls /tmp | grep testrm &gt; /dev/null ; then echo /tmp/testrm is still there; else echo /tmp/testrm is unfortunately gone; fi\necho \"Step 3 - Creation of two test files : 'bonjour' and 'bonjour ; rm -rf \\$TEST'\"\ntouch bonjour 'bonjour ; rm -rf $TEST'\necho -n \"These are the directory files : \" ; ls -1\necho \"Step 4 - Exporting the TEST variable to contain the value of '/tmp/testrm', the directory we want to delete\"\nexport TEST=\"/tmp/testrm\"\necho \"Step 5 - We now run the find command and we use the execdir option to call a bash instance which will run \\\nthe file utility on each file we find\"\nfind -execdir bash -c 'file {}' \\;\necho -n \"Step 6 - We can now see that our test directory has been removed : \"\nif ls /tmp | grep testrm &gt; /dev/null ; then echo /tmp/testrm is still there; else echo /tmp/testrm is unfortunately gone; fi\ncd \"-\" &amp;&amp; rm -rf \"$OLDPWD\" &amp;&amp; echo \"Step 7 - Back in $PWD\"\n</code></pre> <p>In this example we see that our /tmp/testrm directory has been deleted even though we didn't intended at all to do so.  This is because the command 'rm -rf' has been executed when we tried to execute <code>file</code> on our dangerously named file without  sanitizing the input. Even if it is harmless for this example, if the attacker replaces <code>$TEST</code> with <code>$HOME</code> it could be  way more harmful. To prevent this from hapenning, instead of the command <code>find -execdir bash -c 'file {}' \\;</code> we can run the following :</p> <pre><code>find -execdir bash -c 'file \"$@\"' bash '{}' \\;\n</code></pre> <p>to understand precisely what this command do you can go check the -c option in the bash invocation section of the gnu bash manual.</p> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit6/","title":"Bandit6-&gt;7","text":""},{"location":"bandit/docs/bandit6/#level-goal","title":"Level Goal","text":"<p>The password for the next level is stored somewhere on the server and has all of the following properties:</p> <ul> <li>owned by user bandit7</li> <li>owned by group bandit6</li> <li>33 bytes in size</li> </ul>"},{"location":"bandit/docs/bandit6/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>find</li> <li>cat</li> </ul>"},{"location":"bandit/docs/bandit6/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Root Directory</li> <li>Redirection</li> <li>Null Device</li> </ul> <p>See bandit4-&gt;5 and bandit5-&gt;6 for more useful material.</p>"},{"location":"bandit/docs/bandit6/#where-to-start","title":"Where to start?","text":"<p>Let's dive right into the solution, as this level is very similar to the two previous ones.</p>"},{"location":"bandit/docs/bandit6/#walkthrough","title":"Walkthrough","text":"<p>We already know about the <code>size</code> option, we only need to find about the options that allow us to filter the  files using the user and group owning the file. The only thing missing is the fact that the file lies somewhere  on the server. </p> Part 1 : Designating the root of the server Hint <p>Read about the Root Directory</p> Solution <p>From the reading material, we know that we can designate the root of the server with the character <code>/</code>. The command <code>find /</code> will allow us to search everywhere in the server.</p> Part 2 : Finding the relevant options Hint <p>All the options we're looking for are in the section 2 of the gnu findutils documentation</p> Solution <p>Let's take a look at the section 2.8. In this section we can see the two options :</p> <ul> <li><code>user</code></li> <li><code>group</code></li> </ul> <p>Thus we can deduce the resulting command : <code>find / -user bandit7 -group bandit6 -size 33c</code>. We just have to <code>cat</code> the resulting file to get the password.</p> Part 3 : Getting rid of all the error messages <p>Right now, you can see that the output is pretty useless, indeed we need to get rid of all the \"Permission denied\" messages. We need to find a way to get rid of all these error messages, unfortunately <code>find</code> doesn't allow us to do so, but there is a way to get rid of these messages  by putting them in a special file.</p> Hint <p>The information we need lies in two different places. Try to look into : - the section 3 of the gnu bash manual - the null(4) man page</p> Solution <p>In the section 3.6.2 of the gnu bash manual, we can learn more about output redirection.  I think this isn't written directly (but I may be wrong) in the documentation, but the find utility writtes its error messages to stderr (see here  for a more precise documentation about the stderr file). However, we can redirect the output from stderr by redirecting the file descriptor number 2 to a file. The file we're going to redirect to is the file /dev/null (we could also redirect to <code>/dev/zero</code> as writing to any of these file has the same effect). Here is the full command <code>find / -user bandit7 -group bandit6 -size 33c 2&gt; /dev/zero</code>. We can then run cat on the file we retrieved.</p> Full Solution <ol> <li><code>find / -user bandit7 -group bandit6 -size 33c 2&gt; /dev/zero</code> to retrieve the only file that meets the requirements without printing all the error messages</li> <li><code>cat retrieved_file</code> where retrieved_file is the file we got from the first step to dump the password string to stdout.</li> </ol> Info <p>We could also use the one-liner : <code>find / -user bandit7 -group bandit6 -size 33c -execdir cat '{}' \\; 2&gt; /dev/zero</code> to dump only the password string to stdout</p> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit7/","title":"Bandit7-&gt;8","text":""},{"location":"bandit/docs/bandit7/#level-goal","title":"Level Goal","text":"<p>The password for the next level is stored in the file data.txt next to the word millionth.</p>"},{"location":"bandit/docs/bandit7/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>grep</li> <li>file optionnal</li> <li>head optionnal</li> <li>wc optionnal</li> <li>cut optionnal</li> </ul>"},{"location":"bandit/docs/bandit7/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Grep Wikipedia Page</li> <li>Cut Wikipedia Page</li> </ul>"},{"location":"bandit/docs/bandit7/#where-to-start","title":"Where to start?","text":"<p>This Level is actually pretty easy and straightforward. We'll start by analysing the file and then we'll  look for the command we need to complete our goal.</p> Part 1 : File Analysis <p>Let's first run the <code>file</code> utility on our data.txt file to know the type of content we have to deal with  and to ensure that the file is not a malicious file that an attacker may have put in the directory to our intention. Here is the output from the <code>file</code> command : <pre><code>bandit7@bandit:~$ file data.txt \ndata.txt: Unicode text, UTF-8 text\nbandit7@bandit:~$\n</code></pre></p> <p>Now that we know that it is safe to run <code>cat</code> or any other utility that operates on text files on data.txt, let's try to run the head utility on this file.</p> Info <p>The <code>head</code> utility allows us to print only the few first lines (10 by default) of a file.</p> <p>Here is the output from the <code>head</code> utility : <pre><code>bandit7@bandit:~$ head data.txt\ngallop  hu3ZhCrGRvfaO5jsY6ttvApzVCA2Hjvs\nAurelia's   ikl4F3cK5m6Cl6HAxva6zUAVJhI2Cvc6\nstoicism    JiW9ts44udf20bJHe8H5dS1c99Muwz42\nembodies    vWheZcAsQHZNnerI3ViW8wqOKIx0kbgR\nPlato   dW2U8E5FfuAvNLdGDupP8GAxr922ZV0x\ncultivation A90E75jvWbEKrijFxM4GxqHEw8c8U2Bf\nstable  omR4PHolFwbI0IEJsanveA21yWvFy8a7\nbedspread   VlBFxuEDi3phEpljbKbahRJvJxfh3k9M\noppressing  hQTiEm5XF3cUQSEiBjh7sekemLOKBrcJ\ndarnedest   9O2zdCLKVoW5u34P9T7EKTZXcMRE6xh5\nbandit7@bandit:~$ \n</code></pre></p> <p>Now we can get a better feel of how our file is built. We can run a last test on the file in order to get an idea of how many data we'll have to search in order to retrieve the information we're looking for. Let's try to run the wc utility on the file to count how many lines there are in it. We'll give it the <code>-l</code> option to ensure that only the line count gets printed.</p> <p>Here is the output from the <code>wc</code> utility :</p> <pre><code>bandit7@bandit:~$ wc -l data.txt \n98567 data.txt\nbandit7@bandit:~$\n</code></pre> <p>We now know that there are close to 100k lines in the data.txt file. This analysis is not always useful but it can give valuable insight. Let's now move on to the actual challenge, the password retrieval</p> Part 2 : Password retrieval <p>After learning more about the file structure, we can get a feel of which command will be useful to retrieve our password string. Let's take a look at the <code>grep</code> utility to know if we can use it to retrieve our password.</p> Hint <p>Looking into the grep man page, figure out how we can retrieve any line containing the word millionth in the file data.txt</p> Solution <p>By running the command <code>grep millionth data.txt</code> we can retrieve any line containing the word millionth in the file <code>data.txt</code>. The password string will be the second column of that file</p> Full Solution <ol> <li><code>grep millionth data.txt</code> to retrieve the only line containing the world millionth which also contains the password string, we can now copy and paste this password to go to the next level</li> </ol> Bonus : Cutting the output <p>Once we ran grep on our file, we get the following output :  <pre><code>bandit7@bandit:~$ grep millionth data.txt\nmillionth   password_string\nbandit7@bandit:~$\n</code></pre></p> <p>We can now use the <code>cut(1)</code> utility to split the line we got into fields and only retrieve  the field we need.</p> Hint <p>To know how to properly use the <code>cut</code> utility, look into the cut documentation page.</p> Solution <p>By running the line we got through a pipe and transferring its data to <code>cut</code> we can retrieve only the second field. Here is the full command : <pre><code>grep millionth data.txt | cut -f 2\n</code></pre></p> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit8/","title":"Bandit8-&gt;9","text":""},{"location":"bandit/docs/bandit8/#level-goal","title":"Level Goal","text":"<p>The password for the next level is stored in the file data.txt and is the only line of text that occurs only once</p>"},{"location":"bandit/docs/bandit8/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>sort</li> <li>uniq</li> </ul>"},{"location":"bandit/docs/bandit8/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Pipes Linux</li> <li>Redirections Bash</li> </ul>"},{"location":"bandit/docs/bandit8/#where-to-start","title":"Where to start?","text":"<p>To get more information about the file analysis, go to the previous challenge.</p> <p>We now need to get the only line of text that occurs only once in the file data.txt. To do so we'll do the process in reverse.</p> Part 1 : Uniquifying the file <p>The <code>uniq</code> utility allows us to discard repeated input lines, what it does is that it compares the consecutive lines to see if they're (or aren't) identical to each other.</p> Hint <p>Using the uniq gnu documentation, can you figure out what option we need to keep only the input lines that occurs only once?</p> Solution <p>The option <code>-u</code> is the option we'll need to complete our goal. Let's break down what it does. Here is a quote from the documentation :</p> <p>The <code>-u</code> option : \"Discard the last line that would be output for a repeated input group. When used by itself, this option causes uniq to print unique lines, and nothing else.\" First let's try and see what would be the last line outputed for a repeated input group : it is the first line of the group. This means that <code>uniq -u</code> discards the only line which  would be outputed for a group. This indeed means that <code>uniq -u</code> only prints the unique lines.</p> <p>However we know from the same documentation that <code>uniq</code> operates on consecutive lines, thus we need a way to make the lines consecutive to compare them.</p> Part 2 : Sorting text files <p>We need a way to <code>sort</code> the input to apply our <code>uniq</code> filter to it.</p> Hint <p>By looking into the sort gnu documentation, can you figure out how to sort the input for the uniq filter to work?</p> Solution <p>It's fairly simple, we don't need any option at all. By running <code>sort data.txt</code>, we will output the result of the sorted output to stdout.</p> Full Solution <p><code>sort data.txt | uniq -u</code> is the full command that will allow us to get the full password string.</p> <ol> <li><code>sort data.txt</code> will allow us to sort the input in order for uniq to see the consecutive repeated lines.</li> <li><code>|</code> the pipe will allow the sort and uniq processes to communicate.</li> <li><code>uniq -u</code> will dump the only unique line to stdout.</li> </ol> <p>You can now jump to the next level</p>"},{"location":"bandit/docs/bandit9/","title":"Bandit9-&gt;10","text":""},{"location":"bandit/docs/bandit9/#level-goal","title":"Level Goal","text":"<p>The password for the next level is stored in the file data.txt in one of the few human-readable strings, preceded by several \u2018=\u2019 characters.</p>"},{"location":"bandit/docs/bandit9/#commands-useful-to-solve-the-level","title":"Commands useful to solve the level","text":"<ul> <li>file</li> <li>strings</li> <li>grep</li> </ul>"},{"location":"bandit/docs/bandit9/#helpful-reading-material","title":"Helpful Reading Material","text":"<ul> <li>Strings Utility</li> </ul>"},{"location":"bandit/docs/bandit9/#where-to-start","title":"Where to start?","text":"<p>As with the two previous levels, we are going to start by running <code>file</code> on our data.txt file. Here is the output from this command : <pre><code>bandit9@bandit:~$ file data.txt \ndata.txt: data\nbandit9@bandit:~$\n</code></pre> We can now see that we are not dealing with a text file anymore, thus meaning that we can't use the utilities we're used to to retrieve our password.</p> Part 1 : Printing human-readable strings <p>To safely print human-readable strings in non text files, we can use the <code>strings</code> command. We need to figure out how to use this command to print the few human-readle strings in data.txt</p> Hint <p>Try to look in the <code>strings(1)</code> man page and find out how to use the <code>strings</code> utility to achieve this goal</p> Solution <p>We can use the <code>--all</code> option to ensure that all the file is scanned (this should be the default behavior but under certain implementations, the default behavior could be different so this will prevent the exploitation of any BFD library vulnerabilities). Thus, the command we're looking for is <code>strings --all data.txt</code>, which will dump the human-readable strings to stdout. Now, we just need to grep the character '=' in this output and look for the password string.</p> Full Solution <p>Here is the full command : <pre><code>strings --all data.txt | grep =\n</code></pre> We then need to look for the string that looks the most like what could be a password string, preceded by several '=' characters</p> Bonus : Using the size of the password string <p>We know that the password string is a 33 characters long string, so we know that the line we're looking for is at least 33 characters long.  We are going to find a way to display only the (at least) 33 characters long strings in data.txt.</p> Hint <p>Reading the <code>strings(1)</code> man page, can you figure out an option to achieve this goal?</p> Solution <p>The option we're looking for is the <code>-n</code> option, we'll call it with <code>-33</code> which means that we're looking for at least 33 characters long strings.</p> <p>Here is the full command : <pre><code>strings --all -33 data.txt\n</code></pre> This command prints only one line, which contains the password we're looking for.</p> <p>You can now jump to the next level</p>"}]}